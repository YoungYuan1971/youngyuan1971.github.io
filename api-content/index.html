{"posts":[{"title":"Python pip 安装和使用","content":"pip 是 Python 包管理工具，该工具提供了对 Python 包的查找、下载、安装、卸载的功能。 目前如果你在 python.org 下载最新版本的安装包，则是已经自带了该工具。 [!Caution] Python 2.7.9 + 或 Python 3.4+ 以上版本都自带 pip 工具。 pip 官网：https://pypi.org/project/pip/ 你可以通过以下命令来判断是否已安装： # Python3.x 版本命令 pip3 --version 如果你还未安装，则可以使用以下方法来安装： # 下载安装脚本 curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py # 运行安装脚本 sudo python get-pip.py [!Caution] 注意：用哪个版本的 Python 运行安装脚本，pip 就被关联到哪个版本，如果是 Python3 则执行以下命令： # 运行安装脚本 sudo python3 get-pip.py 一般情况 pip 对应的是 Python 2.7，pip3 对应的是 Python 3.x。 部分 Linux 发行版可直接用包管理器安装 pip，如 Debian 和 Ubuntu： sudo apt-get install python-pip pip 最常用命令 显示版本和路径 pip --version 获取帮助 pip --help 升级 pip python -m pip install --upgrade pip # or: pip install -U pip [!TIP] 如果这个升级命令出现问题 ，可以使用以下命令： sudo easy_install --upgrade pip 安装包 pip install [Package] # 最新版本 pip install [Package]==1.0.4 # 指定版本 pip install '[Package]&gt;=1.0.4' # 最小版本 比如要安装 Django。用以下的一条命令就可以，方便快捷。 pip install Django==1.7 升级包 pip install --upgrade [Package] # or: pip install -U [Package] 升级指定的包，通过使用==, &gt;=, &lt;=, &gt;, &lt; 来指定一个版本号。 卸载包 pip uninstall [Package] 卸载包及依赖项 # 需安装 pip-autoremove pip install pip-autoremove # 卸载包及依赖项 pip-autoremove [Package] 搜索包 pip search [Package] 显示安装包信息 pip show [Package] 查看指定包的详细信息 pip show -f [Package] 列出已安装的包 pip list 查看可升级的包 pip list -o # or: pip list --outdated pip 升级 Linux 或 macOS pip install --upgrade pip # python2.x pip3 install --upgrade pip # python3.x Windows 平台升级： python -m pip install -U pip # python2.x python -m pip3 install -U pip # python3.x pip 清华大学开源软件镜像站 使用国内镜像速度会快很多： 临时使用： pip install -i https://pypi.tuna.tsinghua.edu.cn/simple [Package] 例如，安装 Django： pip install -i https://pypi.tuna.tsinghua.edu.cn/simple Django 如果要设为全局永久默认，需要升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置： pip install -U pip pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip： pip install -U pip -i https://pypi.tuna.tsinghua.edu.cn/simple 注意事项 如果 Python2 和 Python3 同时有 pip，则使用方法如下： Python2： python2 -m pip install [Package] Python3: python3 -m pip install [Package] ","link":"https://youngyuan1971.github.io/post/Python pip 安装和使用/"},{"title":"Chrome开发者工具调试反重定向(页面关闭)","content":" 在使用开发者工具调试时，有些网站针对f12或开发者工具快捷键进行检测。如果被检测到，会重定向页面或直接关闭。 对于以上问题，解决办法是通过内容替换等手段，使用本地经过修改的js文件进行替换。 本文案例为某土地网aHR0cHM6Ly9sYW5kY2hpbmEuY29tLyMvc3VwcGx5UGxhbg== chrome浏览器环境 打开浏览器空白页，并使用f12或option+command+i[1]打开开发者工具，切换到Source面板，勾选事件侦听断点--window--window.close 进入某土地网网页，断点会停在window.close()处，在该js文件标签页上右键选择覆盖内容（内容替换）。 网页会跳出权限类的提示，选择允许，并在本地选择一个文件夹，作为替换文件的存放目录。 注释掉相关检测内容：防止浏览器关闭 置空返回值：反键盘和鼠标检测 针对控制台无限刷新的问题，注释掉如下代码并保存command+s[2]，最后去掉勾选window--window.close选项 千万别忘了保存！ 千万别忘了保存！ 千万别忘了保存！ 重新刷新页面，即可正常调试代码。 注释： 这是macos的快捷键，windows的快捷键是Ctrl+Shift+I ↩︎ 这是macos的快捷键，windows的快捷键是Ctrl+S ↩︎ ","link":"https://youngyuan1971.github.io/post/Chrome开发者工具调试反重定向(页面关闭)/"},{"title":"Pandas读取网页表格数据","content":"对于静态加载的数据，使用pd.read_html() import pandas as pd url_static = &quot;http://www.fortunechina.com/fortune500/c/2023-08/02/content_436877.htm&quot; df1 = pd.read_html(url_static, header=0)[0] print(df1) 对于动态加载的数据，直接访问接口，使用pd.read_json() import pandas as pd url_dynamic = &quot;http://31.push2.eastmoney.com/api/qt/clist/get?&quot; \\ &quot;pn=1&amp;pz=9999&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;&quot; \\ &quot;fltt=2&amp;invt=2&amp;wbp2u=|0|0|0|web&amp;fid=f3&amp;fs=m:0+t:6,m:0+t:80,m:1+t:2,m:1+t:23,m:0+t:81+s:2048&amp;&quot; \\ &quot;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f22,&quot; \\ &quot;f11,f62,f128,f136,f115,f152&amp;_=1689749812327&quot; datas = pd.read_json(url_dynamic)['data']['diff'] result = [] for data in datas: data_info = { '代码': data['f12'], '名称': data['f14'], '最新价': data['f2'], '涨跌幅': data['f3'], '涨跌额': data['f4'], '成交量(手)': data['f5'], '成交额': data['f6'], '振幅': data['f7'], '最高价': data['f15'], '最低价': data['f16'], '今开': data['f17'], '昨收': data['f18'], '量比': data['f10'], '换手率': data['f8'], '市盈率(动态)': data['f9'], '市净率': data['f23'] } result.append(data_info) df2 = pd.DataFrame(result) print(df2) ","link":"https://youngyuan1971.github.io/post/Pandas读取网页表格数据/"},{"title":"Markdown运行代码块中的代码","content":"在vscode中编辑markdown文档 需要安装Markdown All in One插件，以支持markdown文件操作 markdown运行代码块 需要安装Markdown Preview Enhanced插件，以支持markdown文件实时预览和运行代码块等操作 举例： ```python {cmd=True} 代码... ``` 按shift+enter，执行光标所在代码块中的代码 按shift+ctrl+enter，执行所有代码 注意：上述操作有一定风险，须谨慎使用 ","link":"https://youngyuan1971.github.io/post/Markdown 运行代码块中的代码/"},{"title":"Python速查卡","content":" 大佬 Laurent Pointal 针对Python的相关基础知识，整理了A4纸大小的正反面篇幅，供Python爱好者学习 英文版本 中文版本 ","link":"https://youngyuan1971.github.io/post/Python速查卡/"},{"title":"MySQL常用命令","content":"登录MySQL mysql -h&lt;remote-IP&gt; -u&lt;username&gt; -p&lt;password&gt; # 或者: mysql -u&lt;username&gt; -p 增加新用户 grant &lt;权限&gt; on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot; 例：增加一个用户Alex密码为123456，让其可以在本机上登录， 并对所有数据库有查询、插入、修改、删除的权限。首先用以root用户连入mysql，然后键入以下命令： grant select,insert,update,delete on . to Alex@localhost Identified by “123456”; 如果希望该用户能够在任何机器上登陆mysql，则将localhost改为%。 操作数据库 登录到mysql中，然后在mysql的提示符mysql&gt;下运行下列命令，每个命令以;结束。 显示数据库列表 show databases; 建库与删库 create database 库名(character set utf8); drop database 库名; 选择数据库 use &lt;DatabaseName&gt;; 导入.sql文件命令(例D:mysql.sql): source mysql.sql; 显示库中的数据表 show tables; 显示数据表的结构 describe 表名; desc 表名; 建表与删表 create table 表名(字段列表); drop table 表名; 清空表中记录 delete from 表名; 显示表中的记录 select * from 表名; 往表中加入记录 insert into 表名 values (字段列表); 更新表中数据 update 表名 set 字段=&quot;值&quot; where 条件 order by 条件 limit 条件; WHERE：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行 ORDER BY：可选项。用于限定表中的行被修改的次序 LIMIT：可选项。用于限定被修改的行数 导出和导入数据 导出数据 mysqldump --opt test &gt; mysql.test # 即将数据库test数据库导出到mysql.test文本文件 # 例：mysqldump -uroot -p用户密码 --databases dbname &gt; mysql.dbname 导入数据 mysqlimport -uroot -p用户密码 &lt; mysql.dbname 将文本数据导入数据库 # 文本数据的字段数据之间用tab键隔开 use test; load data local infile &quot;文件名&quot; into table 表名; 退出MySQL命令 exit ","link":"https://youngyuan1971.github.io/post/MySQL常用命令/"},{"title":"iTerm2配置与美化","content":"1、安装iTerm2 到iTerm官网下载，或： brew install --cask iterm2 2、安装oh-my-zsh 到oh-my-zsh阅读相关文档 执行如下脚本进行安装 sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 3、安装powerlevel10k主题 cd ～/.oh-my-zsh/themes git clone https://github.com/romkatv/powerlevel10k.git vi ~/.zshrc 设置如下内容以使用p10k主题 ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; 4、安装语法高亮插件和自动补全插件 安装方式与theme大同小异： cd ~/.oh-my-zsh/custom/plugins/ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git git clone https://github.com/zsh-users/zsh-autosuggestions 下载完插件后退出iterm2 接下来vi ~/.zshrc在插件配置处添加下载的这两个插件名 plugins=( git zsh-syntax-highlighting zsh-autosuggestions ) 另外历史记录时间戳可以改成如下格式 HIST_STAMPS=&quot;yyyy-mm-dd&quot; 5、向导模式进行p10k的主题定制 在iTerm2中输入以下代码 p10k configure 定制过程中第一步提示下载字体，然后按照向导根据你喜欢的风格进行主题定制 6、若使用NerdFonts字体 去官网下载，并安装 ","link":"https://youngyuan1971.github.io/post/iTerm2配置与美化/"},{"title":"Docker安装MySQL","content":"docker安装MySQL 第一步：在dockerhub上搜索mysql镜像 第二步：拉取的mysql镜像 docker pull mysql:latest docker images 第三步：在宿主机创建mysql目录，例如： cd /home/&lt;username&gt;/docker/data mkdir mysql cd mysql 第四步：启动运行mysql容器 docker run -p 3306:3306 -d \\ --name mysql \\ --restart always \\ -v $(pwd)/mysql-files:/var/lib/mysql-files \\ -v $(pwd)/conf:/etc/mysql/conf.d \\ -v $(pwd)/logs:/var/log \\ -v $(pwd)/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ mysql:latest # 对于arm64v8框架，建议使用如下镜像 docker pull arm64v8/mysql 第五步：进入/退出容器 # 进入容器 docker exec -it mysql bash # 退出容器 exit 第六步：登录 一定要先进入mysql容器 mysql -uroot -p123456 第七步：设置mysql开机自启动（可选） docker update mysql --restart=always 第八步：查看MySQL版本 mysql --version ","link":"https://youngyuan1971.github.io/post/Docker安装MySQL/"},{"title":"Pandas官方重要知识点速查表","content":" 在做数据分析时都会用到 Pandas。虽然 Pandas 的功能十分强大。但是实际用的时候，并不能快速地找到对应的解决方案，那么其实 Pandas 官方早就提供了一份知识框架，放在了 Github 上。 地址：https://github.com/pandas-dev/pandas/tree/master/doc/cheatsheet 这两张图片一共归纳了 13 类常用的 Pandas 操作: 1、数据创建 介绍了几种常用的 DataFrame 创建语法 2、数据重塑 这部分主要是一些在数据清洗中常用的方法，比如数据连接、数据排序、数据删除等，并且还对四个常用的操作给出了图示 3、数据筛选 这一块区域主要是分别用行/列来讲解一些常用的数据查看、抽样、切片等操作，包含了tail、head、loc、iloc等非常重要的方法，并且同样给出了部分动画便于理解 4、数据探索 这一块主要给出了一些在进行探索性分析时常用的方法，比如max、min、count等，不过官方将 apply 放在这里，并没有展开讲解 5、数据修改 这两个区域为缺失值处理和创建新的列，重点用动画示例了assign和qcut方法，缺失值处理部分给出了两个方法 6、数据分组 主要就是groupby和相关方法 7、数据连接 这里介绍的还是非常详细！用图片例子来展示pd.merge中的各种参数变化的不同 8、绘制图表 绘制可视化图表是 Pandas 的一个重要功能 具体操作，还是以官方文档为主。 ","link":"https://youngyuan1971.github.io/post/Pandas官方重要知识点速查表/"},{"title":"Python处理日期与时间","content":"Python的时间处理模块在日常的使用中用的较多多，但是使用的时候基本上都是要查资料，还是有些麻烦的，梳理下，便于以后方便的使用。 目录 时间相关概念 Python time模块 时间格式化计时器功能time模块其他内置函数time模块包含的属性 datetime模块 date类time类datetime类timedelta类tzinfo类 pytz模块 时区转换夏令时处理 dateutil模块 parser.parse()rrule.rrule() Arrow UTC 时间当地时间解析时间Unix 时间戳格式化日期和时间转换为区域时间工作日移动时间夏令时人性化的日期和时间 ISO 8601类 时间相关概念 秒 在1967年的第13届国际度量衡会议上决定以原子时定义的秒作为时间的国际标准单位：铯133原子基态的两个超精细能阶间跃迁对应辐射的9,192,631,770个周期的持续时间, 起始历元定在1958年1月1日0时。 原子钟是一种时钟，它以原子共振频率标准来计算及保持时间的准确。原子钟是世界上已知最准确的时间测量和频率标准。 GMT 格林威治标准时间（Greenwich Mean Time），是指位于伦敦郊区的皇家格林威治天文台的标准时间，因为本初子午线（Prime meridian）被定义为通过那里的经线。GMT也叫世界时UT。 UTC 协调世界时间（Coordinated Universal Time）, 又称世界标准时间，基于国际原子钟，误差为每日数纳秒。协调世界时的秒长与原子时的秒长一致，在时刻上则要求尽量与世界时接近（规定二者的差值保持在 0.9秒以内）。 闰秒 不只有闰年，还有闰秒。闰秒是指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中（也可能在季末）对协调世界时增加或减少1秒的调整。由于地球自转的不均匀性和长期变慢性（主要由潮汐摩擦引起的），会使世界时（民用时）和原子时之间相差超过到±0.9秒时，就把世界时向前拨1秒（负闰秒，最后一分钟为59秒）或向后拨1秒（正闰秒，最后一分钟为61秒）； 闰秒一般加在公历年末或公历六月末。 时区 是地球上的区域使用同一个时间定义。有关国际会议决定将地球表面按经线从南到北，划分成24个时区，并且规定相邻区域的时间相差1小时。当人们跨过一个区域，就将自己的时钟校正1小时（向西减1小时，向东加1小时），跨过几个区域就加或减几小时。比如我大中国处于东八区，表示为GMT+8。 夏令时 （Daylight Saving Time：DST），又称日光节约时制、日光节约时间或夏令时间。这是一种为节约能源而人为规定地方时间的制度，在夏天的时候，白天的时间会比较长，所以为了节约用电，因此在夏天的时候某些地区会将他们的时间定早一小时，也就是说，原本时区是8点好了，但是因为夏天太阳比较早出现，因此把时间向前挪，在原本8点的时候，订定为该天的9点(时间提早一小时)～如此一来，我们就可以利用阳光照明，省去了花费电力的时间，因此才会称之为夏季节约时间！ Unix时间戳 指的是从协调世界时（UTC）1970年1月1日0时0分0秒开始到现在的总秒数，不考虑闰秒。 Python time模块 在 Python 文档里，time是归类在Generic Operating System Services中，换句话说， 它提供的功能是更加接近于操作系统层面的。通读文档可知，time 模块是围绕着 Unix Timestamp 进行的。 该模块主要包括一个类 struct_time，另外其他几个函数及相关常量。 需要注意的是在该模块中的大多数函数是调用了所在平台C library的同名函数， 所以要特别注意有些函数是平台相关的，可能会在不同的平台有不同的效果。另外一点是，由于是基于Unix Timestamp，所以其所能表述的日期范围被限定在 1970 – 2038 之间，如果你写的代码需要处理在前面所述范围之外的日期，那可能需要考虑使用datetime模块更好。 获取当前时间和转化时间格式 time() 返回时间戳格式的时间 (相对于1.1 00:00:00以秒计算的偏移量) ctime() 返回字符串形式的时间，可以传入时间戳格式时间，用来做转化 asctime() 返回字符串形式的时间，可以传入struct_time形式时间，用来做转化 localtime() 返回当前时间的struct_time形式，可传入时间戳格式时间，用来做转化 gmtime() 返回当前时间的struct_time形式，UTC时区(0时区) ，可传入时间戳格式时间，用来做转化 import time time.time() # 1473386416.954 time.ctime() # 'Fri Sep 09 10:00:25 2016' time.ctime(time.time()) # 'Fri Sep 09 10:28:08 2016' time.asctime() # 'Fri Sep 09 10:22:40 2016' time.asctime(time.localtime()) # 'Fri Sep 09 10:33:00 2016' time.localtime() # time.struct_time(tm_year=2016, tm_mon=9, tm_mday=9, tm_hour=10, tm_min=1, tm_sec=19, tm_wday=4, tm_yday=253, tm_isdst=0) time.localtime(time.time()) # time.struct_time(tm_year=2016, tm_mon=9, tm_mday=9, tm_hour=10, tm_min=19, tm_sec=11, tm_wday=4, tm_yday=253, tm_isdst=0) time.gmtime() # time.struct_time(tm_year=2016, tm_mon=9, tm_mday=9, tm_hour=2, tm_min=13, tm_sec=10, tm_wday=4, tm_yday=253, tm_isdst=0) time.gmtime(time.time()) # time.struct_time(tm_year=2016, tm_mon=9, tm_mday=9, tm_hour=2, tm_min=15, tm_sec=35, tm_wday=4, tm_yday=253, tm_isdst=0) struct_time共有9个元素，其中前面6个为年月日时分秒，后面三个分别代表的含义为： tm_wday 一周的第几天（周日是0） tm_yday 一年的第几天 tm_isdst 是否是夏令时 时间格式化 time.mktime() 将一个以struct_time格式转换为时间戳 time.mktime(time.localtime()) # 1473388585.0 time.strftime(format[,t]) 把一个struct_time时间转化为格式化的时间字符串。如果t未指定，将传入time.localtime()。如果元组中任何一个元素越界，ValueError的错误将会被抛出。 %c 本地相应的日期和时间表示 %x 本地相应日期 %X 本地相应时间 %y 去掉世纪的年份（00 – 99） %Y 完整的年份 %m 月份（01 – 12） %b 本地简化月份名称 %B 本地完整月份名称 %d 一个月中的第几天（01 – 31） %j 一年中的第几天（001 – 366） %U 一年中的星期数。（00 – 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。 %W 和%U基本相同，不同的是%W以星期一为一个星期的开始。 %w 一个星期中的第几天（0 – 6，0是星期天） %a 本地（locale）简化星期名称 %A 本地完整星期名称 %H 一天中的第几个小时（24小时制，00 – 23） %I 第几个小时（12小时制，01 – 12） %p 本地am或者pm的相应符，“%p”只有与“%I”配合使用才有效果。 %M 分钟数（00 – 59） %S 秒（01 – 61），文档中强调确实是0 – 61，而不是59，闰年秒占两秒 %Z 时区的名字（如果不存在为空字符） %% ‘%’字符 time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) # '2016-09-09 10:54:21' time.strptime(string[,format]) 把一个格式化时间字符串转化为struct_time。实际上它和strftime()是逆操作。 time.strptime(time.ctime()) # time.struct_time(tm_year=2016, tm_mon=9, tm_mday=9, tm_hour=11, tm_min=0, tm_sec=4, tm_wday=4, tm_yday=253, tm_isdst=-1) 计时器功能 time.sleep(secs) 线程推迟指定的时间运行。单位为秒。 time.clock() 这个需要注意，在不同的系统上含义不同。在UNIX系统上，它返回的是“进程时间”，它是用秒表示的浮点数（时间戳）。而在WINDOWS中，第一次调用，返回的是进程运行的实际时间。而第二次之后的调用是自第一次调用以后到现在的运行时间。（实际上是以WIN32上QueryPerformanceCounter()为基础，它比毫秒表示更为精确） import time time.sleep(1) print(&quot;clock1:%s&quot; % time.clock()) time.sleep(1) print(&quot;clock2:%s&quot; % time.clock()) time.sleep(1) print(&quot;clock3:%s&quot; % time.clock()) 运行结果为： # clock1:1.57895443216e-06 # clock2:1.00064381867 # clock3:2.00158724394 其中第一个clock()输出的是程序运行时间，第二、三个clock()输出的都是与第一个clock的时间间隔 time模块其他内置函数 altzone() 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 tzset() 根据环境变量TZ重新初始化时间相关设置。 time模块包含的属性 timezone 是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲;&lt;=0大部分欧洲，亚洲，非洲）。 tzname 包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称和不带的。 import time print(time.timezone) print(time.tzname) print(time.tzname[0].decode(&quot;GBK&quot;)) print(time.tzname[1].decode(&quot;GBK&quot;)) 运行结果 # -28800 # ('\\xd6\\xd0\\xb9\\xfa\\xb1\\xea\\xd7\\xbc\\xca\\xb1\\xbc\\xe4', '\\xd6\\xd0\\xb9\\xfa\\xcf\\xc4\\xc1\\xee\\xca\\xb1') # 中国标准时间 # 中国夏令时 datetime模块 datetime 比 time 高级了不少，可以理解为 datetime 基于 time 进行了封装，提供了更多实用的函数。 datetime模块定义了下面这几个类： date：表示日期的类。常用的属性有year, month, day time：表示时间的类。常用的属性有hour, minute, second, microsecond datetime：表示日期时间 timedelta：表示时间间隔，即两个时间点之间的长度 tzinfo：与时区有关的相关信息 注：上面这些类型的对象都是不可变（immutable）的。 date类 date类定义了一些常用的类方法与类属性: max、min：date对象所能表示的最大、最小日期 resolution：date对象表示日期的最小单位。这里是天 today()：返回一个表示当前本地日期的date对象 fromtimestamp(timestamp)：根据给定的时间戮，返回一个date对象 fromordinal(ordinal)：将Gregorian日历时间转换为date对象(特殊历法用不上) from datetime import date import time print('date.max:', date.max) print('date.min:', date.min) print('date.resolution:', date.resolution) print('date.today():', date.today()) print('date.fromtimestamp():', date.fromtimestamp(time.time())) 执行结果： # date.max: 9999-12-31 # date.min: 0001-01-01 # date.resolution: 1 day, 0:00:00 # date.today(): 2016-09-12 # date.fromtimestamp(): 2016-09-12 date提供的实例方法和属性： .year：返回年 .month：返回月 .day：返回日 .replace(year, month, day)：生成一个新的日期对象，用参数指定的年，月，日代替原有对象中的属性。（原有对象仍保持不变） .weekday()：返回weekday，如果是星期一，返回0；如果是星期2，返回1，以此类推 .isoweekday()：返回weekday，如果是星期一，返回1；如果是星期2，返回2，以此类推 .isocalendar()：返回格式如(year, wk num, wk day) .isoformat()：返回格式如’YYYY-MM-DD’的字符串 .strftime(fmt)：自定义格式化字符串。与time模块中的strftime类似。 .toordinal()：返回日期对应的Gregorian Calendar日期 from datetime import date today = date.today() print('today:', today) print('.year:', today.year) print('.month:', today.month) print('.replace():', today.replace(year=2017) ) print('.weekday():', today.weekday()) print('.isoweekday():', today.isoweekday()) print('.isocalendar():', today.isocalendar()) print('.isoformat():', today.isoformat()) print('.strftime():', today.strftime('%Y-%m-%d') ) print('.toordinal():', today.toordinal()) 执行结果： # today: 2016-09-12 # .year: 2016 # .month: 9 # .replace(): 2017-09-12 # .weekday(): 0 # .isoweekday(): 1 # .isocalendar(): (2016, 37, 1) # .isoformat(): 2016-09-12 # .strftime(): 2016-09-12 # .toordinal(): 736219 date还对某些操作进行了重载，它允许我们对日期进行如下一些操作： date2 = date1 + timedelta # 日期加上一个间隔，返回一个新的日期对象 date2 = date1 – timedelta # 日期减去一个间隔，返回一个新的日期对象 timedelta = date1 – date2 # 两个日期相减，返回一个时间间隔对象 date1 &lt; date2 # 两个日期进行比较 time类 time类的构造函数如下：（其中参数tzinfo，它表示时区信息。） class datetime.time(hour[, minute[, second[, microsecond[, tzinfo]]]]) time类定义的类属性： min、max：time类所能表示的最小、最大时间。其中，time.min = time(0, 0, 0, 0)， time.max = time(23, 59, 59, 999999) resolution：时间的最小单位，这里是1微秒 time类提供的实例方法和属性： .hour、.minute、.second、.microsecond：时、分、秒、微秒 .tzinfo：时区信息 .replace([hour[, minute[, second[, microsecond[, tzinfo]]]]])：创建一个新的时间对象，用参数指定的时、分、秒、微秒代替原有对象中的属性（原有对象仍保持不变）； .isoformat()：返回型如”HH:MM:SS”格式的字符串表示； .strftime(fmt)：返回自定义格式化字符串。 像date一样，也可以对两个time对象进行比较，或者相减返回一个时间间隔对象。这里就不提供例子了。 datetime类 datetime是date与time的结合体，包括date与time的所有信息。它的构造函数如下：datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])，各参数的含义与date、time的构造函数中的一样，要注意参数值的范围。 datetime类定义的类属性与方法： min、max：datetime所能表示的最小值与最大值； resolution：datetime最小单位； today()：返回一个表示当前本地时间的datetime对象； now([tz])：返回一个表示当前本地时间的datetime对象，如果提供了参数tz，则获取tz参数所指时区的本地时间； utcnow()：返回一个当前utc时间的datetime对象； fromtimestamp(timestamp[, tz])：根据时间戮创建一个datetime对象，参数tz指定时区信息； utcfromtimestamp(timestamp)：根据时间戮创建一个datetime对象； combine(date, time)：根据date和time，创建一个datetime对象； strptime(date_string, format)：将格式字符串转换为datetime对象； from datetime import datetime import time print('datetime.max:', datetime.max) print('datetime.min:', datetime.min) print('datetime.resolution:', datetime.resolution) print('today():', datetime.today()) print('now():', datetime.now()) print('utcnow():', datetime.utcnow()) print('fromtimestamp(tmstmp):', datetime.fromtimestamp(time.time())) print('utcfromtimestamp(tmstmp):', datetime.utcfromtimestamp(time.time())) 运行结果： # datetime.max: 9999-12-31 23:59:59.999999 # datetime.min: 0001-01-01 00:00:00 # datetime.resolution: 0:00:00.000001 # today(): 2016-09-12 19:57:00.761000 # now(): 2016-09-12 19:57:00.761000 # utcnow(): 2016-09-12 11:57:00.761000 # fromtimestamp(tmstmp): 2016-09-12 19:57:00.761000 # utcfromtimestamp(tmstmp): 2016-09-12 11:57:00.761000 datetime类提供的实例方法与属性（很多属性或方法在date和time中已经出现过，在此有类似的意义，这里只罗列这些方法名，具体含义不再逐个展开介绍，可以参考上文对date与time类的讲解。）： year、month、day、hour、minute、second、microsecond、tzinfo： date()：获取date对象； time()：获取time对象； replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])： timetuple() utctimetuple() toordinal() weekday() isocalendar() isoformat([sep]) ctime()：返回一个日期时间的C格式字符串，等效于ctime(time.mktime(dt.timetuple()))； strftime(format) 像date一样，也可以对两个datetime对象进行比较，或者相减返回一个时间间隔对象，或者日期时间加上一个间隔返回一个新的日期时间对象。 timedelta类 通过timedelta函数返回一个timedelta对象，也就是一个表示时间间隔的对象。函数参数情况如下所示: class datetime.timedelta([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]]) 其没有必填参数，简单控制的话第一个整数就是多少天的间隔的意思: datetime.timedelta(10) 两个时间间隔对象可以彼此之间相加或相减，返回的仍是一个时间间隔对象。而更方便的是一个datetime对象如果减去一个时间间隔对象，那么返回的对应减去之后的datetime对象，然后两个datetime对象如果相减返回的是一个时间间隔对象。这很是方便。 tzinfo类 tzinfo是一个抽象类，不能被直接实例化。需要派生子类，提供相应的标准方法。datetime模块并不提供tzinfo的任何子类。最简单的方式是使用pytz模块。 pytz模块 pytz是Python的一个时区处理模块（同时也包括夏令时），在理解时区处理模块之前，需要先要了解一些时区的概念。 要知道时区之间的转换关系，其实这很简单：把当地时间减去当地时区，剩下的就是格林威治时间了。例如北京时间的18:00就是18:00+08:00，相减以后就是10:00+00:00，因此就是格林威治时间的10:00。 Python的datetime可以处理2种类型的时间，分别为offset-naive和offset-aware。前者是指没有包含时区信息的时间，后者是指包含时区信息的时间，只有同类型的时间才能进行减法运算和比较。 datetime模块的函数在默认情况下都只生成offset-naive类型的datetime对象，例如now()、utcnow()、fromtimestamp()、utcfromtimestamp()和strftime()。其中now()和fromtimestamp()可以接受一个tzinfo对象来生成offset-aware类型的datetime对象，但是标准库并不提供任何已实现的tzinfo类，只能自己实现。 下面就是实现格林威治时间和北京时间的tzinfo类的例子： ZERO_TIME_DELTA = timedelta(0) LOCAL_TIME_DELTA = timedelta(hours=8) # 本地时区偏差 class UTC(tzinfo): def utcoffset(self, dt): return ZERO_TIME_DELTA def dst(self, dt): return ZERO_TIME_DELTA class LocalTimezone(tzinfo): def utcoffset(self, dt): return LOCAL_TIME_DELTA def dst(self, dt): return ZERO_TIME_DELTA def tzname(self, dt): return '+08:00' 一个tzinfo类需要实现utcoffset、dst和tzname这3个方法。其中utcoffset需要返回夏时令的时差调整；tzname需要返回时区名，如果你不需要用到的话，也可以不实现。 一旦生成了一个offset-aware类型的datetime对象，我们就能调用它的astimezone()方法，生成其他时区的时间（会根据时差来计算）。而如果拿到的是offset-naive类型的datetime对象，也是可以调用它的replace()方法来替换tzinfo的，只不过这种替换不会根据时差来调整其他时间属性。因此，如果拿到一个格林威治时间的offset-naive类型的datetime对象，直接调用replace(tzinfo=UTC())即可转换成offset-aware类型，然后再调用astimezone()生成其他时区的datetime对象。 看上去一切都很简单，但不知道你还是否记得上文所述的夏时令。提起夏时令这个玩意，真是让我头疼，因为它没有规则可循：有的国家实行夏时令，有的国家不实行，有的国家只在部分地区实行夏时令，有的地区只在某些年实行夏时令，每个地区实行夏时令的起止时间都不一定相同，而且有的地方TMD还不是用几月几日来指定夏时令的起止时间的，而是用某月的第几个星期几这种形式。 pytz模块，使用Olson TZ Database解决了跨平台的时区计算一致性问题，解决了夏令时带来的计算问题。由于国家和地区可以自己选择时区以及是否使用夏令时，所以pytz模块在有需要的情况下得更新自己的时区以及夏令时相关的信息。 pytz提供了全部的timezone信息，如： import pytz print(len(pytz.all_timezones)) print(len(pytz.common_timezones)) 运行结果： # 588 # 436 如果需要获取某个国家的时区，可以使用如下方式： import pytz print(pytz.country_timezones('cn')) 执行结果： [u'Asia/Shanghai', u'Asia/Urumqi'] 中国一个有两个时区，一个为上海，一个为乌鲁木齐，我们来看下我们有什么区别： from datetime import datetime import pytz print(pytz.country_timezones('cn')) tz1 = pytz.timezone(pytz.country_timezones('cn')[0]) print(tz1) print(datetime.now(tz1)) tz2 = pytz.timezone(pytz.country_timezones('cn')[1]) print(tz2) print(datetime.now(tz2)) 执行结果： # [u'Asia/Shanghai', u'Asia/Urumqi'] # Asia/Shanghai # 2016-09-14 09:55:39.384000+08:00 # Asia/Urumqi # 2016-09-14 07:55:39.385000+06:00 可以看到上海是东八区，而乌鲁木齐是东六区。 时区转换 操作起来有而比较简单，本地时区与UTC的互转： from datetime import datetime import pytz now = datetime.now() tz = pytz.timezone('Asia/Shanghai') print(tz.localize(now)) print(pytz.utc.normalize(tz.localize(now))) 执行结果： # 2016-09-14 10:25:44.633000+08:00 # 2016-09-14 02:25:44.633000+00:00 使用astimezone()可以进行时区与时区之间的转换。 from datetime import datetime import pytz utc = pytz.utc beijing_time = pytz.timezone('Asia/Shanghai') japan_time = pytz.timezone('Asia/Tokyo') now = datetime.now(beijing_time) print(&quot;Beijing Time:&quot;,now) print(&quot;UTC:&quot;,now.astimezone(utc)) print(&quot;JAPAN TIME:&quot;,now.astimezone(japan_time)) 执行结果： # Beijing Time: 2016-09-14 10:19:22.671000+08:00 # UTC: 2016-09-14 02:19:22.671000+00:00 # JAPAN TIME: 2016-09-14 11:19:22.671000+09:00 另外可以采用 replace来修改时区，时区多出6分钟（不要使用）。具体原因为： 民國17年（1928年），國民政府統一中國，原中央觀象台的業務由南京政府中央研究院的天文研究所和氣象研究所分別接收。天文研究所編寫的曆書基本上沿襲中央觀象台的做法，仍將全國劃分為5個標準時區，只是在有關交氣、合朔、太陽出沒時刻等處，不再使用北平的地方平時，而改以南京所在的標準時區的區時即東經120°標準時替代。從北平地方平時改為東經120°標準時，兩者相差了352秒。 from datetime import datetime import pytz now = datetime.now() print(now) tz = pytz.timezone('Asia/Shanghai') print(now.replace(tzinfo=tz)) 执行结果： # 2016-09-14 10:29:20.200000 # 2016-09-14 10:29:20.200000+08:06 夏令时处理 由于用到的场景比较少，不做细化学习。 dateutil模块 安装模块：pip install Python-dateutil parser.parse() 解析时间到datetime格式，支持大部分时间字符串。没指定时间默认是0点，没指定日期默认是今天，没指定年份默认是今年。 from dateutil import parser print(parser.parse(&quot;8th March,2004&quot;)) print(parser.parse(&quot;8 March,2004&quot;)) print(parser.parse(&quot;March 8th,2004&quot;)) print(parser.parse(&quot;March 8,2004&quot;)) print(parser.parse(&quot;2016-09-14&quot;)) print(parser.parse(&quot;20160914&quot;)) print(parser.parse(&quot;2016/09/14&quot;)) print(parser.parse(&quot;09/14/2016&quot;)) print(parser.parse(&quot;09,14&quot;)) print(parser.parse(&quot;12:00:00&quot;)) print(parser.parse(&quot;Wed, Nov 12&quot;)) 执行结果： # 2004-03-08 00:00:00 # 2004-03-08 00:00:00 # 2004-03-08 00:00:00 # 2004-03-08 00:00:00 # 2016-09-14 00:00:00 # 2016-09-14 00:00:00 # 2016-09-14 00:00:00 # 2016-09-14 00:00:00 # 2016-09-09 00:00:00 # 2016-09-14 12:00:00 # 2016-11-12 00:00:00 rrule.rrule() 函数主要功能：按照规则生成日期和时间。函数原型如下。 rrule(self, freq, dtstart=None, interval=1, wkst=None, count=None, until=None, bysetpos=None, bymonth=None, bymonthday=None, byyearday=None, byeaster=None, byweekno=None, byweekday=None, byhour=None, byminute=None, bysecond=None, cache=False) 其中： freq:可以理解为单位。可以是 YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY。即年月日周时分秒。 dtstart,until:是开始和结束时间。 wkst:周开始时间。 interval:间隔。 count:指定生成多少个。 byxxx:指定匹配的周期。比如byweekday=(MO,TU)则只有周一周二的匹配。byweekday可以指定MO,TU,WE,TH,FR,SA,SU。即周一到周日。 更多参考：http://dateutil.readthedocs.io/en/stable/index.html Arrow Arrow 提供了一个友好而且非常易懂的方法，用于创建时间、计算时间、格式化时间，还可以对时间做转化、提取、兼容 python datetime 类型。它包括dateutil模块，根据其文档描述Arrow旨在“帮助你使用更少的代码来处理日期和时间”。 UTC 时间 使用utcnow()功能创建 UTC 时间。 使用to()方法，我们将 UTC 时间转换为本地时间。 import arrow utc = arrow.utcnow() print(utc) print(utc.to('local')) 当地时间 本地时间是特定区域或时区中的时间。 import arrow now = arrow.now() print(now) print(now.to('UTC')) 使用now()功能创建本地时间。 to()方法用于将本地时间转换为 UTC 时间。 解析时间 get()方法用于解析时间。 import arrow d1 = arrow.get('2012-06-05 16:20:03', 'YYYY-MM-DD HH:mm:ss') print(d1) d2 = arrow.get(1504384602) print(d2) 该示例从日期和时间字符串以及时间戳解析时间。 Unix 时间戳 import arrow utc = arrow.utcnow() print(utc) unix_time = utc.timestamp print(unix_time) date = arrow.Arrow.fromtimestamp(unix_time) print(date) 该示例显示本地时间和 Unix 时间。 然后，它将 Unix 时间转换回 date 对象。 使用fromtimestamp()方法，我们将 Unix 时间转换回 Arrow 日期对象。 也可以将日期格式化为 Unix 时间。 import arrow utc = arrow.utcnow() print(utc.format('X')) 通过将’X’说明符传递给format()方法，我们将当前本地日期打印为 Unix 时间。 格式化日期和时间 日期和时间可以用format()方法格式化。 import arrow now = arrow.now() year = now.format('YYYY') print(&quot;Year: {0}&quot;.format(year)) date = now.format('YYYY-MM-DD') print(&quot;Date: {0}&quot;.format(date)) date_time = now.format('YYYY-MM-DD HH:mm:ss') print(&quot;Date and time: {0}&quot;.format(date_time)) date_time_zone = now.format('YYYY-MM-DD HH:mm:ss ZZ') print(&quot;Date and time and zone: {0}&quot;.format(date_time_zone)) 转换为区域时间 import arrow utc = arrow.utcnow() print(utc.to('US/Pacific').format('HH:mm:ss')) print(utc.to('Europe/Bratislava').format('HH:mm:ss')) print(utc.to('Europe/Moscow').format('HH:mm:ss')) 工作日 可以使用weekday()或format()方法找到日期的工作日。 import arrow d1 = arrow.get('1948-12-13') print(d1.weekday()) print(d1.format('dddd')) 移动时间 shift()方法用于移动时间。 import arrow now = arrow.now() print(now.shift(hours=5).time()) print(now.shift(days=5).date()) print(now.shift(years=-8).date()) 夏令时 import arrow now = arrow.now() print(now.format(&quot;YYYY-MM-DD HH:mm:ss ZZ&quot;)) print(now.dst()) 该示例使用dst()显示夏令时。 人性化的日期和时间 在社交网站上，我们经常可以看到诸如“一个小时前”或“ 5 分钟前”之类的术语，这些术语可以为人们提供有关帖子创建或修改时间的快速信息。 Arrow 包含humanize()方法来创建此类术语。 import arrow now = arrow.now() d1 = now.shift(minutes=-15).humanize() print(d1) d2 = now.shift(hours=5).humanize() print(d2) ISO 8601类 国际标准ISO 8601，是国际标准化组织的日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》，在API接口开发中涉及的比较多。 import dateutil.parser dateutil.parser.parse('2008-09-03T20:56:35.450686Z') # RFC 3339 format datetime.datetime(2008, 9, 3, 20, 56, 35, 450686, tzinfo=tzutc()) dateutil.parser.parse('2008-09-03T20:56:35.450686') # ISO 8601 extended format datetime.datetime(2008, 9, 3, 20, 56, 35, 450686) dateutil.parser.parse('20080903T205635.450686') # ISO 8601 basic format datetime.datetime(2008, 9, 3, 20, 56, 35, 450686) dateutil.parser.parse('20080903') # ISO 8601 basic format, date only datetime.datetime(2008, 9, 3, 0, 0) 或者使用如下方式解析： datetime.datetime.strptime(&quot;2008-09-03T20:56:35.450686Z&quot;, &quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;) 另外还可以使用iso8601模块：http://pyiso8601.readthedocs.io/en/latest/ 其他日期与时间工具： 公历转农历：https://pypi.python.org/pypi/LunarSolarConverter/ 口语化日期：https://github.com/scrapinghub/dateparser Moment：https://github.com/zachwill/moment Delorean：https://github.com/myusuf3/delorean When：https://whenpy.readthedocs.io/en/latest/ Pendulum：https://pendulum.eustace.io/ 时间机器：https://github.com/spulec/freezegun 工作日历：https://github.com/peopledoc/workalendar 中国法定节假日：https://github.com/NateScarlet/holiday-cn ","link":"https://youngyuan1971.github.io/post/Python处理日期与时间/"},{"title":"PowerBI/Excel批量爬取网页数据","content":"本文以智联招聘网站为例，采集工作地点在上海的职位发布信息。 下面是详细操作步骤： （一）分析网址结构 打开智联招聘网站，搜索工作地点在上海的数据， 下拉页面到最下面，找到显示页码的地方，点击前三页，网址分别如下， http://sou.zhaopin.com/jobs/searchresult.ashx?jl=%e4%b8%8a%e6%b5%b7&amp;sm=0&amp;sg=fe782ca83bfa4b018d27de559d0a5db0&amp;p=1 http://sou.zhaopin.com/jobs/searchresult.ashx?jl=%e4%b8%8a%e6%b5%b7&amp;sm=0&amp;sg=fe782ca83bfa4b018d27de559d0a5db0&amp;p=2 http://sou.zhaopin.com/jobs/searchresult.ashx?jl=%e4%b8%8a%e6%b5%b7&amp;sm=0&amp;sg=fe782ca83bfa4b018d27de559d0a5db0&amp;p=3 可以看出最后一个数字就是页码的ID，是控制分页数据的变量。 （二）使用PowerBI采集第一页的数据 打开PowerBI Desktop，从网页获取数据，从弹出的窗口中选择【高级】，根据上面分析的网址结构，把除了最后一个页码ID的网址输入第一行，页码输入第二行， 从URL预览中可以看出，已经自动把上面两行的网址合并到一起；这里分开输入只是为了后面更清晰的区分页码变量，其实直接输入全网址也是一样可以操作的。（如果页码变量不是最后一位，而是在中间，应该分三行输入网址）。点击确定后，发现出来很多表 从这里可以看出，智联招聘网站上每一条招聘信息都是一个表格，不用管它，任意选择一个表格，比如勾选Table0，点击编辑进入Power Query编辑器。 在PQ编辑器中直接删除掉【源】之后的所有步骤，然后展开数据，并把前面没有的几列数据删除。 这样第一页的数据就采集过来了。然后对这一页的数据进行整理，删除掉无用信息，添加字段名，可以看出一页包含60条招聘信息。 这里整理好第一页数据以后，下面进行采集其他页面时，数据结构都会和第一页整理后的数据结构一致，采集的数据可以直接拿来用；这里不整理也没关系，可以等到采集所有网页数据后一起整理。 如果要大批量的抓取网页数据，为了节省时间，对第一页的数据可以先不整理，直接进入下一步。 （三）根据页码参数设置自定义函数 这是最重要的一步。 还是刚才第一页数据的PQ编辑器窗口，打开【高级编辑器】，在let前输入： (p as number) as table =&gt; 并把let后面第一行的网址中，&amp;后面的&quot;1&quot;改为（这就是第二步使用高级选项分两行输入网址的好处）： (Number.ToText(p)) 更改后【源】的网址变为： &quot;http://sou.zhaopin.com/jobs/searchresult.ashx?jl=%e4%b8%8a%e6%b5%b7&amp;sm=0&amp;sg=fe782ca83bfa4b018d27de559d0a5db0&amp;p=&quot;&amp;(Number.ToText(p)))), 确定以后，刚才第一页数据的查询窗口直接变成了自定义函数的输入参数窗口，Table0表格也变成了函数的样式。为了更直观，把这个函数重命名为Data_Zhaopin. 到这里自定义函数完成，p是该函数的变量，用来控制页码，随便输入一个数字，比如7，将抓取第7页的数据， 输入参数只能一次抓取一个网页，要想批量抓取，还需要下面这一步。 （四）批量调用自定义函数 首先使用空查询建立一个数字序列，如果想抓取前100页的数据，就建立从1到100的序列，在空查询中输入 ={1..100} 回车就生成了从1到100的序列，然后转为表格。gif操作图如下： 然后调用自定义函数， 在弹出的窗口中点击【功能查询】下拉框，选择刚才建立的自定义函数Data_Zhaopin,其他都按默认就行 点击确定，就开始批量抓取网页了，因为100页数据比较多，耗时5分钟左右，这也是我第二步提前数据整理造成的后果，导致抓取比较慢。展开这一个表格，就是这100页的数据， 至此，批量抓取智联招聘100页的信息完成，上面的步骤看起来很多，实际上熟练掌握以后，10分钟左右就可以搞定，最大块的时间还是最后一步进行抓取数据的过程比较耗时。 网页的数据是不断更新的，在操作完以上的步骤之后，在PQ中点击刷新，可以随时一键提取网站实时的数据，一次做好，终生受益！ 以上主要使用的是PowerBI中的Power Query功能，在可以使用PQ功能的Excel中也是可以同样操作的。 当然PowerBI并不是专业的爬取工具，如果网页比较复杂或者有防爬机制，还是得用专业的工具，比如Python。在用PowerBI批量抓取某网站数据之前，先尝试着采集一页试试，如果可以采集到，再使用以上的步骤，如果采集不到，就不用再耽误工夫了。 另一种方法(视频) ","link":"https://youngyuan1971.github.io/post/Excel批量爬取网页数据/"},{"title":"Mac将App程序打包成为dmg","content":"1. 新建DMG 打开磁盘工具，新建DMG File-&gt;New Image-&gt;Blank Image 创建DMG 2. 添加文件 在磁盘工上右键打开 右键-&gt;Show in Finder 创建快捷键 ln -s /Applications Applications 完成文件添加 3. 排版，添加背景 修改排版 右键-&gt;Show View Options 自定义背景 4. 压缩DMG 推出DMG 转换DMG 压缩DMG 压缩后的文件明显小于原文件，也不可再进行编辑 5. 完成打包 至此，完成了App打包DMG，可以进行共享发布了 ","link":"https://youngyuan1971.github.io/post/Mac将App程序打包成为dmg/"},{"title":"Pandas函数","content":"不管是业务数据分析 ，还是数据建模。数据处理都是及其重要的一个步骤，它对于最终的结果来说，至关重要。 今天，就为大家总结一下 “Pandas数据处理” 几个方面重要的知识。 导入数据 导出数据 查看数据 数据选取 数据处理 数据分组和排序 数据合并 import pandas as pd 导入数据 pd.DataFrame() pd.read_csv(filename) pd.read_table(filename) pd.read_excel(filename) pd.read_sql(query,connection_object) pd.read_json(json_string) pd.read_html(url) 导出数据 df.to_csv(filename) df.to_excel(filename) df.to_sql(table_name,connection_object) df.to_json(filename) writer=pd.ExcelWriter('test.xlsx',index=False) df1.to_excel(writer,sheet_name='单位')和writer.save()，将多个数据帧写⼊同⼀个⼯作簿的多个sheet(⼯作表) 查看数据 df.head(n) # 查看DataFrame对象的前n⾏ df.tail(n) # 查看DataFrame对象的最后n⾏ df.shape() # 查看⾏数和列数 df.info() # 查看索引、数据类型和内存信息 df.columns() # 查看字段（⾸⾏）名称 df.describe() # 查看数值型列的汇总统计 s.value_counts(dropna=False) # 查看Series对象的唯⼀值和计数 df.apply(pd.Series.value_counts) # 查看DataFrame对象中每⼀列的唯⼀值和计数 df.isnull().any() # 查看是否有缺失值 df[df[column_name].duplicated()] # 查看column_name字段数据重复的数据信息 df[df[column_name].duplicated()].count() # 查看column_name字段数据重复的个数 数据选取 df[col] # 根据列名，并以Series的形式返回列 df[[col1,col2]] # 以DataFrame形式返回多列 s.iloc[0] # 按位置选取数据 s.loc['index_one'] # 按索引选取数据 df.iloc[0,:] # 返回第⼀⾏ df.iloc[0,0] # 返回第⼀列的第⼀个元素 df.loc[0,:] # 返回第⼀⾏（索引为默认的数字时，⽤法同df.iloc），但需要注意的是loc是按索引,iloc参数只接受数字参数 df.ix[[:5],[&quot;col1&quot;,&quot;col2&quot;]] # 返回字段为col1和col2的前5条数据，可以理解为loc和 iloc的结合体。 df.at[5,&quot;col1&quot;] # 选择索引名称为5，字段名称为col1的数据 df.iat[5,0] # 选择索引排序为5，字段排序为0的数据 数据处理 df.columns= ['a','b','c'] # 重命名列名（需要将所有列名列出，否则会报错） pd.isnull() # 检查DataFrame对象中的空值，并返回⼀个Boolean数组 pd.notnull() # 检查DataFrame对象中的⾮空值，并返回⼀个Boolean数组 df.dropna() # 删除所有包含空值的⾏ df.dropna(axis=1) # 删除所有包含空值的列 df.dropna(axis=1,thresh=n) # 删除所有⼩于n个⾮空值的⾏ df.fillna(value=x) # ⽤x替换DataFrame对象中所有的空值，⽀持 df[column_name].fillna(x) s.astype(float) # 将Series中的数据类型更改为float类型 s.replace(1,'one') # ⽤‘one’代替所有等于1的值 s.replace([1,3],['one','three']) # ⽤'one'代替1，⽤'three'代替3 df.rename(columns=lambdax:x+1) # 批量更改列名 df.rename(columns={'old_name':'new_ name'}) # 选择性更改列名 df.set_index('column_one') # 将某个字段设为索引，可接受列表参数，即设置多个索引 df.reset_index(&quot;col1&quot;) # 将索引设置为col1字段，并将索引新设置为0,1,2... df.rename(index=lambdax:x+1) # 批量重命名索引 数据分组和排序 df.sort_index().loc[:5] # 对前5条数据进⾏索引排序 df.sort_values(col1) # 按照列col1排序数据，默认升序排列 df.sort_values(col2,ascending=False) # 按照列col1降序排列数据 df.sort_values([col1,col2],ascending=[True,False]) # 先按列col1升序排列，后按col2降序排列数据 df.groupby(col) # 返回⼀个按列col进⾏分组的Groupby对象 df.groupby([col1,col2]) # 返回⼀个按多列进⾏分组的Groupby对象 df.groupby(col1)[col2].agg(mean) # 返回按列col1进⾏分组后，列col2的均值,agg可以接受列表参数，agg([len,np.mean]) df.pivot_table(index=col1,values=[col2,col3],aggfunc={col2:max,col3:[ma,min]}) # 创建⼀个按列col1进⾏分组，计算col2的最⼤值和col3的最⼤值、最⼩值的数据透视表 df.groupby(col1).agg(np.mean) # 返回按列col1分组的所有列的均值,⽀持 df.groupby(col1).col2.agg(['min','max']) data.apply(np.mean) # 对DataFrame中的每⼀列应⽤函数np.mean data.apply(np.max,axis=1) # 对DataFrame中的每⼀⾏应⽤函数np.max df.groupby(col1).col2.transform(&quot;sum&quot;) # 通常与groupby连⽤，避免索引更改 数据合并 df1.append(df2) # 将df2中的⾏添加到df1的尾部 df.concat([df1,df2],axis=1,join='inner') # 将df2中的列添加到df1的尾部,值为空的对应⾏与对应列都不要 df1.join(df2.set_index(col1),on=col1,how='inner') # 对df1的列和df2的列执⾏SQL形式的join，默认按照索引来进⾏合并，如果df1和df2有共同字段时，会报错，可通过设置lsuffix,rsuffix来进⾏解决，如果需要按照共同列进⾏合并，就要⽤到set_index(col1) pd.merge(df1,df2,on='col1',how='outer') # 对df1和df2合并，按照col1，⽅式为outer pd.merge(df1,df2,left_index=True,right_index=True,how='outer') #与 df1.join(df2, how='outer')效果相同 ","link":"https://youngyuan1971.github.io/post/Pandas函数/"},{"title":"20条非常实用的Python代码实例","content":"1、合并两个字典 Python3.5之后，合并字典变得容易起来。我们可以通过**符号解压字典，并将多个字典传入{}中，实现合并。 def Merge(dict1, dict2): res = {**dict1, **dict2} return res dict1 = {&quot;name&quot;: &quot;Joy&quot;, &quot;age&quot;: 25} dict2 = {&quot;name&quot;: &quot;Joy&quot;, &quot;city&quot;: &quot;New York&quot;} dict3 = Merge(dict1, dict2) print(dict3) 输出： {'name': 'Joy', 'age': 25, 'city': 'New York'} 2、链式比较 python有链式比较的机制，在一行里支持多种运算符比较。相当于拆分多个逻辑表达式，再进行逻辑与操作。 a = 5 print(2 &lt; a &lt; 8) print(1 == a &lt; 3) 输出： True False 3、重复打印字符串 将一个字符串重复打印多次，一般使用循环实现，但有更简易的方式可以实现。 n = 5 string = &quot;Hello!&quot; print(string * n) 输出： Hello!Hello!Hello!Hello!Hello! 4、检查文件是否存在 Python有专门处理系统交互的模块-os，它可以处理文件的各种增删改查操作。 from os import path def check_for_file(): print(&quot;Does file exist:&quot;, path.exists(&quot;data.csv&quot;)) if __name__==&quot;__main__&quot;: check_for_file() 输出： Does file exist: False 5、检索列表最后一个元素 在使用列表的时候，有时会需要取最后一个元素，有下面几种方式可以实现。 my_list = ['banana', 'apple', 'orange', 'pineapple'] last_element = my_list[-1] last_element = my_list.pop() 输出： 'pineapple' 6、列表推导式 列表推导式是for循环的简易形式，可以在一行代码里创建一个新列表，同时能通过if语句进行判断筛选 def get_vowels(string): return [vowel for vowel in string if vowel in 'aeiou'] print(&quot;Vowels are:&quot;, get_vowels('This is some random string')) 输出： Vowels are: ['i', 'i', 'o', 'e', 'a', 'o', 'i'] 7、计算代码执行时间 python中time模块提供了时间处理相关的各种函数方法，我们可以使用它来计算代码执行的时间。 import time start_time = time.time() total = 0 for i in range(10): total += i print(&quot;Sum:&quot;, total) end_time = time.time() time_taken = end_time - start_time print(&quot;Time: &quot;, time_taken) 输出： Sum: 45 Time: 0.0009975433349609375 8、查找出现次数最多的元素 使用max方法找出列表中出现次数最多的元素。 def most_frequent(list): return max(set(list), key=list.count) mylist = [1,1,2,3,4,5,6,6,2,2] print(&quot;出现次数最多的元素是:&quot;, most_frequent(mylist)) 输出： 出现次数最多的元素是: 2 9、将两个列表转换为字典 有两个列表，将列表A里的元素作为键，将列表B里的对应元素作为值，组成一个字典。 def list_to_dictionary(keys, values): return dict(zip(keys, values)) list1 = [1, 2, 3] list2 = ['one', 'two', 'three'] print(list_to_dictionary(list1, list2)) 输出： {1: 'one', 2: 'two', 3: 'three'} 10、异常处理 Python提供了try...except...finally的方式来处理代码异常，当然还有其他组合的方式。 a, b = 1,0 try: print(a/b) except ZeroDivisionError: print(&quot;Can not divide by zero&quot;) finally: print(&quot;Executing finally block&quot;) 输出： Can not divide by zero Executing finally block 11、反转字符串 使用切片操作对字符串进行反转，这是比较直接有效的方式。 这也可以用来检测回文数。 str = &quot;Hello World&quot; print(&quot;反转后字符串是:&quot;, str[::-1]) 输出： 反转后字符串是: dlroW olleH 12、字符串列表组成单个字符串 使用join方法将字符串列表组成单个字符串。 list = [&quot;Hello&quot;, &quot;world&quot;, &quot;Ok&quot;, &quot;Bye!&quot;] combined_string = &quot; &quot;.join(list) print(combined_string) 输出： Hello world Ok Bye! 13、返回字典缺失键的默认值 字典中的get方法用于返回指定键的值，如果键不在字典中返回默认值 None 或者设置的默认值。 dict = {1:'one', 2:'two', 4:'four'} print(dict.get(3, 'three')) print(&quot;原始字典:&quot;, dict) 输出： three 原始字典: {1: 'one', 2: 'two', 4: 'four'} 14、交换两个变量的值 在不使用临时变量的前提下，交换两个变量的值。 a, b = 5, 10 a, b = b, a def swap(a,b): return b,a swap(a,b) 15、正则表达式 正则表达式用来匹配处理字符串，python中的re模块提供了全部的正则功能。 import re text = &quot;The rain in spain&quot; result = re.search(&quot;rain&quot;, text) print(True if result else False) 输出： True 16、筛选值 python中的filter方法可以用来进行值的筛选。 my_list = [0,1,2,3,6,7,9,11] result = filter(lambda x: x % 2!=0, my_list) print(list(result)) 输出： [1, 3, 7, 9, 11] 17、统计字频 判断字符串每个元素出现的次数，可以用collections模块中的Counter方法来实现，非常简洁。 from collections import Counter result = Counter('banana') print(result) 输出： Counter({'a': 3, 'n': 2, 'b': 1}) 18、变量的内存占用 如何输出python中变量的内存占用大小，可以通过sys模块来实现。 import sys var1 = 15 list1 = [1,2,3,4,5] print(sys.getsizeof(var1)) print(sys.getsizeof(list1)) 输出： 28 104 19、链式函数调用 在一行代码中调用多个函数。 def add(a, b): return a + b def subtract(a, b): return a - b a, b = 5, 10 print((add if b &gt; a else subtract)(a,b)) 输出： 15 20、从列表中删除重复项 删除列表中重复项一般可以通过遍历来筛选去重，或者直接使用集合方法。 list1 = [1,2,3,3,4,'John', 'Ana', 'Mark', 'John'] def remove_duplicate(list_value): return list(set(list_value)) print(remove_duplicate(list1)) result = [] [result.append(x) for x in list1 if x not in result] print(result) 输出： [1, 2, 3, 4, 'Ana', 'John', 'Mark'] [1, 2, 3, 4, 'John', 'Ana', 'Mark'] ","link":"https://youngyuan1971.github.io/post/20条非常实用的Python代码实例/"},{"title":"Tampermonkey屏蔽网页指定的元素","content":"--屏蔽今日头条置顶文章 一、使用Chrome插件Adblock Plus 在设置→\\rightarrow→高级设置→\\rightarrow→过滤规则中设置 # 屏蔽置顶文章 toutiao.com##.feed-card-wrapper.feed-card-article-wrapper.sticky-cell # 屏蔽推荐排行 toutiao.com##.ttp-hot-board 二、使用油猴插件 自己编写脚本(使用javascript) // ==UserScript== // @name 屏蔽今日头条置顶文章 // @namespace http://tampermonkey.net/ // @version 1.3 // @description 我的浏览器我做主 // @author YoungYuan // @match *://www.toutiao.com/* // @icon https://www.google.com/s2/favicons?sz=64&amp;domain=toutiao.com // @grant GM_addStyle // @require https://code.jquery.com/jquery-3.6.0.min.js // ==/UserScript== (function () { 'use strict'; let css = ` .feed-card-wrapper.feed-card-article-wrapper.sticky-cell{ display: none } ` GM_addStyle(css) })(); ","link":"https://youngyuan1971.github.io/post/Tampermonkey屏蔽网页指定的元素/"},{"title":"Centos删除多余的Linux内核","content":"删除开机多余kernel（centos） yum update 命令会大范围升级，有时候linux内核也会升级，升级后开机画面就会出现多个内核，可以删除: ⒈ 查看正在使用的内核 uname -a ⒉ 查看系统中的全部内核 rpm -qa | grep kernel ⒊ 删除多余的内核，例如 yum remove -y kernel-3.10.0-957.el7.x86_64 ","link":"https://youngyuan1971.github.io/post/Centos删除多余的Linux内核/"},{"title":"KODI影片刮削器设置","content":" KODI影片刮削器主流是TMDB，但是其服务器在国外，经常会连接不上服务器，是因为DNS解析有问题，被墙了。 我的KODI连接了OpenWrt，在OpenWrt中设置相关DNS劫持即可。 测试TMDB网址的DNS 打开DNS查询网站，分别搜索域名api.themoviedb.org和api.tmdb.org，查看其ip，选取指向香港亚马逊的即可。 设置OpenWrt 登录OpenWrt管理页面，在网络--DHCP/DNS中，添加自定义挟持域名，将TMDB域名和指向ip填入并保存应用 如果ip失效，重复上述两步骤即可 ","link":"https://youngyuan1971.github.io/post/KODI影片刮削器设置/"},{"title":"Python正则表达式","content":" 正则表达式简介 正则表达式，是一个特殊的字符序列，又称规则表达式（英语：Regular Expression，在代码中常简写为regex、regexp 或RE），本质而言是一种小型的，高度专业化的编程语言。 Python 自1.5版本起增加了re 模块，re 模块使Python语言拥有全部的正则表达式功能。 正则语法表 开头结尾 模式 描述 ^ 从整个字符串开头的地方匹配 $ 从整个字符串的结尾开始匹配 模糊匹配 模式 描述 . 匹配任意字符串，除了换行符 ? 重复匹配?号前面0个或1个由前面的正则表达式定义的片段，非贪婪模式 * 重复匹配*号前面0个或多个的表达式 + 重复匹配+号前面1个或多个的表达式 a | b 匹配a或b 关于括号 模式 描述 {} 表示匹配{}前面的字符，指定个数为{}里面的数值 [] 表示一个字符集，它常被用来制定一个字符串类别，字符可以单个列出，也可以用-号分隔的两个给定字符来表示一个字符区间 () 分组，将括号中的内容当作整体来对待 &quot;\\&quot; 反斜杠的应用 模式 描述 \\w 匹配字母、数字、下划线 \\W 匹配非字母、非数字、非下划线 \\s 匹配任意空白字符，等价于[\\t\\n\\r\\f] \\S 匹配任意非空字符 \\d 匹配任意数字，等价于[0-9] \\D 匹配任意非数字 \\A 匹配字符串开始 \\z 匹配字符串结束 \\Z 匹配字符串结束，如果存在换行，只匹配到换行前的结束字符串 \\G 匹配最后匹配完成的位置 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，er\\b可以匹配never中的er，但不能匹配verb中的er \\B 匹配非单词边界，er\\B能匹配verb中的er，但不能匹配never中的er \\n,\\t ...... 匹配一个换行符，匹配一个制表符等 \\1......\\9 匹配第n个分组的内容 \\10 匹配第n个分组的内容，如果经匹配，否则指的是八进制字符码的表达式 re模块用法 re.(function)(pattern[, flags]) pattern : 一个字符串形式的正则表达式 flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M 多行模式 re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符） re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和 # 后面的注释 findall() 即：全部找到,返回的是一个列表 findall(string[, pos[, endpos]]) 参数： string : 待匹配的字符串。 pos : 可选参数，指定字符串的起始位置，默认为 0。 endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。 import re s = 'helloworld hellobeijing' ret = re.findall('hello\\S+',s) print(ret) ['helloworld', 'hellobeijing'] finditer() 和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0) 参数： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等 例如：re.S匹配多行 search() 与 match() 相同点： 语法：re.search/match(pattern, string, flags=0) 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等 例如：re.S匹配多行 3.可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 匹配方法 描述 group(num=0) 匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组 group() 返回一个包含所有小组字符串的元组，从 1 到所含的小组号 start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为0 end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为0 span([group]) 方法返回(start(group), end(group)) import re # re.search ret = re.search('h..','hello hello world') print(ret) # 输出结果：&lt;_sre.SRE_Match object; span=(0, 3), match='hel'&gt; ret1 = re.search('h..','hello hello world').group() print(ret1) # 输出结果：hel 只输出第一个符合条件的结果 # re.match ret = re.match('asd','asdhskdjfksji') print(ret) # 输出结果：&lt;_sre.SRE_Match object; span=(0, 3), match='asd'&gt;返回的是一个对象。 ret1 = re.match('asd','asdhskdjfasdksjiasd').group() print(ret1) # 输出结果：asd 调用.group()方法，只返回匹配的第一个结果。 不同点： re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None re.search匹配整个字符串，直到找到一个匹配 # re.search s = 'helloworld hellobeijing' ret = re.search('hellob\\S+',s) print(ret) &lt;re.Match object; span=(11, 23), match='hellobeijing'&gt; # re.match s = 'helloworld hellobeijing' ret = re.match('hellob\\S+',s) print(ret) None split() 分隔符 对比字符串里边的split方法。 split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： re.split(pattern, string[, maxsplit=0, flags=0]) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 maxsplit 分组次数，maxsplit=1分隔一次，默认为0，不限制次数 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等 例如：re.S匹配多行 import re s = 'helloworld hellobeijing' ret = re.split('hello',s) print(ret) ['', 'world ', 'beijing'] sub() 替换，类似字符串中的replace()方法。 re.sub用于替换字符串中的匹配项。 语法： re.sub(pattern, repl, string, count=0, flags=0) 参数： pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 import re s = 'helloworld hellobeijing' ret = re.sub('hello','goodbye',s) print(ret) goodbyeworld goodbyebeijing compile(strPattern[,flag]) 这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象 compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： re.compile(pattern[, flags]) 参数： pattern : 一个字符串形式的正则表达式 flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M 多行模式 re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符） re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和 # 后面的注释 import re pattern = re.compile('he.{3}') pattern.match(s) &lt;re.Match object; span=(0, 5), match='hello'&gt; ","link":"https://youngyuan1971.github.io/post/Python正则表达式/"},{"title":"Python相关设置(Mac)","content":"一、Python搭建虚拟环境 1.建立目录 mkdir $dir 2.进入目录 cd $dir 3.创建虚拟环境 python3 -m venv $myvenv 4.进入虚拟环境 cd $myvenv 5.激活虚拟环境 source bin/activate 6.退出虚拟环境 deactivate 二、JupiterNotebook管理多个python虚拟环境 查看内核路径 jupyter-kernelspec list 删除多余内核 jupyter kernelspec remove venv0 添加内核，--name后是内核名称，--display-name后是需要显示的名称 python -m ipykernel install --user --name newVenv --display-name &quot;Python3.9&quot; 三、JupyterNotebook代码补全(勾选Nbextensions中的Hinterland) pip install jupyter_contrib_nbextensions jupyter contrib nbextension install --user --skip-running-check 四、更新pip python -m pip install --upgrade pip 五、调用其他目录的包 import sys sys.path.append('dirname/') from &lt;module&gt; import &lt;func&gt; 六、vscode导入包自动排序的问题(忽略自动排序) 打开 VSCode 设置，输入python.formatting.autopep8Args,添加[&quot;--ignore&quot;, &quot;E402&quot;]，让 autopep8 忽略 E402，也就是 “模块级别导入不在文件顶部”错误。 七、python包移植 将已安装的包信息打包到文件 pip freeze &gt;requirements.txt 移植到新环境 pip install -r requirements.txt 八、py文件象notebook一样运行 vscode中，在.py文件行首输入#%%，就可以象jupyter notebook一样，逐行运行代码了 ","link":"https://youngyuan1971.github.io/post/Python相关设置(Mac)/"},{"title":"Python库--shutil优雅的文件和目录操作","content":"shutil 是 Python 的标准库之一，提供了许多文件和目录操作的功能。以下是 shutil 常用的功能列表，并给出了每个功能的简单示例： 文件和目录的复制 (shutil.copy, shutil.copy2, shutil.copyfile, shutil.copytree): import shutil # 复制文件 shutil.copy('source.txt', 'destination.txt') # 复制文件，保留元数据（如访问时间、修改时间等） shutil.copy2('source.txt', 'destination.txt') # 复制文件内容（不包括元数据） shutil.copyfile('source.txt', 'destination.txt') # 复制目录及其内容 shutil.copytree('source_dir', 'destination_dir') 文件和目录的移动和重命名 import shutil # 移动文件或目录 shutil.move('source.txt', 'destination.txt') # 重命名文件或目录 shutil.rename('old_name.txt', 'new_name.txt') 文件和目录的删除 import shutil # 递归删除目录及其内容 shutil.rmtree('directory') # 删除文件 os.remove('file.txt') 压缩和解压缩文件 import shutil # 创建压缩文件（支持多种格式，如 zip、tar、gztar） shutil.make_archive('archive', 'zip', 'directory') # 解压缩压缩文件 shutil.unpack_archive('archive.zip', 'extracted_directory') 文件和目录的权限设置 import shutil # 修改文件或目录的所有者和组 shutil.chown('file.txt', user='new_user', group='new_group') # 修改文件或目录的权限 shutil.chmod('file.txt', mode=0o755) 获取文件大小、获取最后访问时间等 import shutil # 获取磁盘使用情况 usage = shutil.disk_usage('/path/to/directory') print(usage.total, usage.used, usage.free) # 获取文件或目录的最后访问时间、修改时间、创建时间 atime = shutil.getatime('file.txt') mtime = shutil.getmtime('file.txt') ctime = shutil.getctime('file.txt') 目录的遍历 import shutil # 遍历目录及其子目录中的所有文件和文件夹 for root, dirs, files in shutil.walk('directory'): print(root) # 当前遍历的目录 print(dirs) # 当前目录下的子目录 print(files) # 当前目录下的文件 文件和目录的比较 import shutil # 比较两个文件的内容是否相同 same = shutil.cmp('file1.txt', 'file2.txt') # 比较两个目录的内容是否相同 same = shutil.cmp('dir1', 'dir2') 创建临时文件和目录 import shutil # 创建临时文件（返回文件对象和文件路径） temp_file = shutil.mkstemp(suffix='.txt', prefix='temp_', dir='temp_dir') # 创建临时目录（返回目录路径） temp_dir = shutil.mkdtemp(prefix='temp_') 获取文件或目录的状态信息 import shutil # 获取文件或目录的状态信息 stat_info = shutil.stat('file.txt') # 获取文件或目录的大小（字节数） file_size = stat_info.st_size # 获取文件或目录的权限（八进制数表示） file_mode = stat_info.st_mode # 获取文件或目录的最后访问时间 access_time = stat_info.st_atime ","link":"https://youngyuan1971.github.io/post/Python库--shutil优雅的文件和目录操作/"},{"title":"Python库--ddddocr识别图片验证码/滑块验证码准确率极高","content":"前言 验证码的种类有很多，它是常用的一种反爬手段，包括：图片验证码，滑块验证码，等一些常见的验证码场景。 识别验证码的python 库有很多，用起来也并不简单，这里推荐一个简单实用的识别验证码的库 ddddocr (带带弟弟ocr)库. 环境准备 python 版本要求小于等于python3.9版本 pip 安装 pip install ddddocr 下载的安装包比较大，一般用国内的下载源可以加快下载速度 pip install ddddocr -i https://pypi.douban.com/simple github地址https://github.com/sml2h3/ddddocr 快速开始 先随便找个纯英文的验证码,保持为a1.png 代码示例 import ddddocr # 导入 ddddocr ocr = ddddocr.DdddOcr() # 实例化 with open('a1.png', 'rb') as f: # 打开图片 img_bytes = f.read() # 读取图片 res = ocr.classification(img_bytes) # 识别 print(res) 运行结果 已经能识别到 xnen ,但是会出现&quot;欢迎使用ddddocr，本项目专注带动行业内卷...&quot;提示语， 可以加一个参数show_ad=False import ddddocr # 导入 ddddocr ocr = ddddocr.DdddOcr(show_ad=False) # 实例化（目前1.4.7版本默认没有了提示语） with open('a1.png', 'rb') as f: # 打开图片 img_bytes = f.read() # 读取图片 res = ocr.classification(img_bytes) # 识别 print(res) 图片验证码 识别一下三种验证码 代码示例 import ddddocr # 导入 ddddocr ocr = ddddocr.DdddOcr(show_ad=False) # 实例化 with open('a2.png', 'rb') as f: # 打开图片 img_bytes = f.read() # 读取图片 res2 = ocr.classification(img_bytes) # 识别 print(res2) with open('a3.png', 'rb') as f: # 打开图片 img_bytes = f.read() # 读取图片 res3 = ocr.classification(img_bytes) # 识别 print(res3) with open('a4.png', 'rb') as f: # 打开图片 img_bytes = f.read() # 读取图片 res4 = ocr.classification(img_bytes) # 识别 print(res4) 运行结果 giv6j zppk 4Tskhe 滑块验证码 滑块验证码场景如下场景示例 先抠出2张图片，分别为background.png 和 target.png 解决问题的重点是计算缺口的位置 import ddddocr det = ddddocr.DdddOcr(det=False, ocr=False, show_ad=False) with open('target.png', 'rb') as f: target_bytes = f.read() with open('background.png', 'rb') as f: background_bytes = f.read() res = det.slide_match(target_bytes, background_bytes, simple_target=True) print(res) 运行结果 {'target_y': 0, 'target': [184, 58, 246, 120]} target 的四个值就是缺口位置的左上角和右下角的左边位置 识别中文 识别图片上的文字 import ddddocr import cv2 det = ddddocr.DdddOcr(det=True) with open(&quot;test.png&quot;, 'rb') as f: image = f.read() poses = det.detection(image) im = cv2.imread(&quot;test.png&quot;) for box in poses: x1, y1, x2, y2 = box im = cv2.rectangle(im, (x1, y1), (x2, y2), color=(0, 0, 255), thickness=2) cv2.imwrite(&quot;result.jpg&quot;, im) 保存后的图片 ","link":"https://youngyuan1971.github.io/post/Python库--ddddocr识别图片验证码/"},{"title":"Docker搭建相关服务","content":"AList docker run -d --name=&quot;alist&quot; --restart=always -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 xhofe/alist:latest ddddocr docker run -d --name=&quot;ddddocr&quot; --restart=always -p 9898:9898 xhofe/ddddocr_server:main Alist和ddddocr两个容器有关联：前者需要后者为其提供验证码OCR服务。所以最好用docker-compose部署，详见笔记：Docker容器自定义启动顺序 Syncthing docker run -d --name=&quot;syncthing&quot; --restart=always -p 8384:8384 -p 22000:22000/tcp -p 22000:22000/udp -p 21027:21027/udp -v /wherever/st-sync:/var/syncthing --hostname=my-syncthing syncthing/syncthing:1.23.5 Syncthing-Relay-Discosrv docker run -d --name=&quot;Syncthing-Relay-Discosrv&quot; --restart=always -p 22067:22067 -p 8443:8443 johngong/syncthing-relay-discosrv:latest 在syncthing中设置发现和中继服务器地址： https://152.69.216.224:18443/?id=&lt;device id&gt; relay://152.69.216.224:12067?id=&lt;device id&gt; # 查看device id docker logs Syncthing-Relay-Discosrv Pandora(截止2023-12停止更新) docker run -d --name=&quot;pandora&quot; --restart=always -e PANDORA_CLOUD=cloud -e PANDORA_SERVER=0.0.0.0:8899 -p 8899:8899 pengzhile/pandora 通过Token登录，过期后，登录chat.openai，登录后，在开发者工具中获取 PandoraNext(新的项目) docker run -d --restart always --name PandoraNext --net=bridge \\ -p 8181:8181 \\ -v /mnt/sda2/docker/data/pandoranext/data:/data \\ -v /mnt/sda2/docker/data/pandoranext/sessions:/root/.cache/PandoraNext \\ pengzhile/pandora-next 容器内默认监听8181端口，映射宿主机的8181端口，可自行修改 映射目录到容器内的/data目录，config.json、tokens.json 获取license_id 填在config.json中(必须项，否则会报错：License ID is required) 映射目录到容器内的/root/.cache/PandoraNext目录，保留登录的session，避免重启容器登录状态丢失 npc客户端 一款内网穿透工具，需要具有公网IP的服务器，服务器上安装nps服务端 docker run -d --name=&quot;npc&quot; --restart=always --net=host ffdfgdfg/npc -server=&lt;ip:port&gt; -vkey=******&lt;其他参数&gt; my_django_project(自建镜像) 详细操作，例如如何编写Dockerfile文件，请阅读Docker部署Django项目笔记 进入项目根目录后执行： # 创建镜像 docker build -t mysite . # 运行容器 docker run -d --name=&quot;my_django_project&quot; --restart=always -p 8000:8000 -v $(pwd):/app mysite xiaoya(小雅资源) 通过脚本安装docker容器： # 标准模式，打开端口 5678 bash -c &quot;$(curl -s http://docker.xiaoya.pro/update_new.sh)&quot; # host模式(推荐，软路由和NAS上更少网络故障，打开端口 6789) bash -c &quot;$(curl -s http://docker.xiaoya.pro/update_new.sh)&quot; -s host 我已经更改了脚本中的挂载点为/mnt/sda2/docker/data，那么需要上传自定义脚本scp ./Docker_xiaoya.sh &lt;UserName&gt;@&lt;IP&gt;:&lt;Dest_Path&gt;到服务器，然后执行： # 标准模式：端口 5678 ./Docker_xiaoya.sh # host模式：端口 5678 ./Docker_xiaoya.sh -s host 第一次运行脚本需要输入阿里云的相关信息： # 阿里云盘TOKEN（AList官方文档）： 9e3bec188b99484593f40604d0756785 # 阿里云盘OPEN TOKEN（AList官方文档）： eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiI2MmFjMDk3NDJmNzc0ZmE1OWU3M2NhMzc0ZjhjMTA3MCIsImF1ZCI6Ijc2OTE3Y2NjY2Q0NDQxYzM5NDU3YTA0ZjYwODRmYjJmIiwiZXhwIjoxNjk1NjIzOTQ0LCJpYXQiOjE2ODc4NDc5NDR9.LlWjEhvs2cnZXffJPjAWdg9plC12So1U6-gQxQb6Xk9jzHsbK9XNL9dCnYt8g0h2x77yzElbyIxGZq-99PrXQA # 阿里云盘FOLDER ID（浏览器登录阿里云盘进入文件夹，在浏览器地址栏中获取）： 649a8550dd5fd405bd72494c96a021d355d415c3 浏览器访问 启动容器后，等待几分钟加载完内容就可以访问了，我采用了host模式：http://yourIP:6789 AList V3 无法套娃挂载小雅的解决 执行下面代码获取令牌 docker exec -i xiaoya-hostmode sqlite3 data/data.db &lt;&lt;EOF select value from x_setting_items where key = &quot;token&quot;; EOF 把令牌填到Authorization， Server 选用本地的docker地址，不要填账号和密码 AList通过webdav挂载 用户：guest 密码：guest_Api789 地址：http://yourIP:6789/dav registry 搭建docker私有仓库 docker run -d --name DockerRegistry --restart=always -p 5000:5000 -v /mnt/sda2:/var/lib/registry registry 在Linux中，编辑/etc/docker/daemon.json文件，添加仓库信任： { &quot;insecure-registries&quot;: [&quot;yourIP:5000&quot;] } 访问http://yourIP:5000/v2/_catalog，即可看到仓库列表 仓库路径：/mnt/sda2/docker/registry/v2/repositories 青龙面板 docker run -dit \\ -v /mnt/sda2/docker/data/qinglong:/ql/data \\ -p 5700:5700 \\ --name qinglong \\ --hostname qinglong \\ --restart always \\ whyour/qinglong 访问5700端口，进行配置并登录 阿里云盘自动签到 添加依赖项：NodeJs项下axios 添加环境变量 名称：refreshToken 值：个人阿里云盘的Token 添加定时任务 # 拉取脚本命令 ql repo https://github.com/mrabit/aliyundriveDailyCheck.git &quot;autoSignin&quot; &quot;&quot; &quot;qlApi&quot; # 定时规则 0 9 * * * 完成上述后，执行一次任务，然后刷新浏览器。如果成功则会多一条任务autoSignin.js，执行一次该任务，在日志中能看到执行结果。 IPTV播放源自动更新 上传自己编写的python脚本至github仓库 添加依赖项：Python3项下requests 添加定时任务 # 拉取脚本命令 ql repo https://github.com/YoungYuan1971/my_projects.git &quot;iptv_get.py&quot; # 定时规则 0 8 * * * 完成上述后，执行一次任务，然后刷新浏览器，如果成功则会多一条任务iptv_get.py，执行一次该任务，在日志中能看到执行结果。 关于cron表达式 cron详细表达式详见笔记Mac下使用crontab定时任务 表达式也可以在线验证是否正确UU在线工具 Jellyfin服务端 默认端口号：8096 docker run -d \\ --name Jellyfin \\ --restart always \\ -v /mnt/sda2/docker/data/jellyfin/config:/config \\ -v /mnt/sda2/docker/data/jellyfin/cache:/cache \\ -v /mnt/sda2:/media \\ --net=host \\ jellyfin/jellyfin:latest Portainer服务 Portainer是管理Docker的界面化服务 管理界面url：yourIP:9000 docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer-ce pixman(IPTV)服务 Arm/v7 架构系统请使用 pixman/pixman-armv7 镜像，自行修改后面使用方法里的 pixman/pixman 为 pixman/pixman-armv7 一般用法：在播放器中输入http://ip:port/xxx.m3u直接观看，或在浏览器中输入前述地址并下载文件后用播放器打开 docker run -d --name=pixman -p 5050:5000 --restart=always pixman/pixman 导入外部的 m3u 文件，从而通过 http://ip:port/your.m3u 访问： # 挂载后，将 m3u 文件放到 /path/to/yours 目录下，然后通过 http://ip:port/your.m3u 访问 docker run -d --name=pixman -p 5050:5000 -v /path/to/yours:/app/app/data/m3u --restart=always pixman/pixman # 举例： docker run -d --name=pixman -p 5050:5000 -v /mnt/sda2/docker/data/pixman/m3u:/app/app/data/m3u --restart=always pixman/pixman 支持的直播源：ysp.m3u，4gtv.m3u，tptv_proxy.m3u，itv_proxy.m3u等 DrawDB数据库设计 部署： docker run --restart always --name drawdb -p 3000:80 -d ahdev0/drawdb 使用：浏览器输入http://yourIP:3000 ","link":"https://youngyuan1971.github.io/post/Docker搭建相关服务/"},{"title":"Docker一键搭建Alist OCR验证码识别接口","content":" Alist 新版官方 OCR 验证码识别接口失效，下载可以自行搭建（支持 amd64＆arm64 架构） OCR Server Docker 开源地址 Alist OCR Docker 镜像地址 Alist Github 开源地址 Alist V3 文档 Docker搭建 docker run -d --restart=always -p 9898:9898 xhofe/ddddocr_server:main 测试是否启动成功 安装完成后先访问 http://你的IP:9898/ping 测试是否启动成功，如果返回 pong 则启动成功 在Alist里完成配置 之后在 AList 管理-设置-全局-Ocr接口 在浏览器地址栏处输入下面的链接，再点击保存，就可以正常使用了 http://你的IP:9898/ocr/file/json ","link":"https://youngyuan1971.github.io/post/Docker一键搭建Alist OCR验证码识别接口/"},{"title":"Docker容器自定义启动顺序","content":"分析和思路 我们在docker运维的过程中经常会遇到一个问题，我们启动一个docker-compose.yml文件时，虽然我们使用depends_on属性用依赖关系定义了两个容器的启动顺序，但这个顺序仅仅是docker创建启动的顺序，而并不是在上一个容器完全启动成功的情况下启动下一个容器。 比如一个docker-compose.yml脚本中有mysql和依赖此mysql的一个java程序a容器，虽然a容器在mysql启动之后启动，但还是存在a容器启动的时候mysql容器还在启动中，还无法提供可用的数据库连接，这就导致一个问题,a容器此时启动异常或者失败，虽然部分有做异常情况快速失败停止程序触发docker重启机制，但也会导致a容器多次重启。 甚至在部分服务器资源有限的情况下，多个容器同时启动，但因为数据库等容器还未启动导致其他服务多次重启互相抢占系统资源，导致数据库容器也无法正常启动，陷入死循环，甚至严重的导致docker服务直接无响应。 为了实现上诉a容器在mysql容器完全启动可以提供数据库连接的情况下再启动，就需要在a容器中加入一个逻辑来检查等待mysql的3306端口已经打开，然后执行a容器的启动程序语句。 在这里用到了github上的一个开源项目wait-for-it，可以看到其中有一个shell文件wait-for-it.sh，这个自行去github项目中下载，这里以下面的docker-compose.yml为例： version: '3' services: mysql: restart: always image: mysql:5.6 ports: - &quot;3306:3306&quot; env_file: - env/mysql.env app: image: app:latest restart: always env_file: - env/mysql.env ports: - 8054:8054 depends_on: - mysql volumes: - ./wait-for-it.sh:/wait-for-it.sh command: [&quot;/wait-for-it.sh&quot;, &quot;-t&quot;, &quot;0&quot;, &quot;mysql:3306&quot;, &quot;--&quot;, &quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;] 这里将wait-for-it.sh挂载到app容器内，然后设置执行语句command: [&quot;/wait-for-it.sh&quot;, &quot;-t&quot;, &quot;0&quot;, &quot;mysql:3306&quot;, &quot;--&quot;, &quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]，其中mysql:3306代表检查mysql容器的3306端口是否可用，-t 0代表设置超时为0代表禁用超时功能，即wait-for-it脚本一直等mysql服务可用之后再执行后续命令，java -jar app.jar就是app容器原本的java程序启动命令。 实战操作 有两个容器：AList和AList_OCR_Server容器，前者需要依托后者的验证码接口，故需要先启动AList_OCR_Server容器，等待该容器9898端口生效后，再启动AList容器，创建docker-compose.yml，如下： version: '3' services: AList_OCR_Server: container_name: AList_OCR_Server restart: always ports: - 9898:9898 image: xhofe/ddddocr_server:main AList: container_name: AList restart: always volumes: - /etc/alist:/opt/alist/data - ./wait-for-it.sh:/opt/alist/wait-for-it.sh # 将本地的wait-for-it.sh挂载到容器中 ports: - 5244:5244 environment: - PUID=0 - PGID=0 - UMASK=022 depends_on: - AList_OCR_Server # 等待AList_OCR_Server容器启动(但不会检查端口是否生效) image: xhofe/alist:latest command: # 覆盖容器启动后默认执行的命令 [ '/opt/alist/wait-for-it.sh', # 执行wait-for-it.sh脚本 '-t', # -t 0 代表禁用超时 '0', 'AList_OCR_Server:9898', # 等待AList_OCR_Server:9898生效 '--', '/entrypoint.sh' # AList原执行命令 ] docker-compose 可以指定配置文件 docker-compose -f &lt;FileName.yml&gt; up -d ","link":"https://youngyuan1971.github.io/post/Docker容器自定义启动顺序/"},{"title":"Docker基本命令","content":"常用命令 docker images显示镜像列表 docker ps显示容器列表 docker run IMAGE_ID指定镜像, 运行一个容器 docker start/stop/pause/unpause/kill/restart CONTAINER_ID操作容器状态 docker tag IMAGE_ID [REGISTRYHOST/][USERNAME/]NAME[:TAG]给指定镜像命名 docker pull/push NAME:TAG下载, 推送镜像到 Docker registry server , NAME 部分包括了服务地址 docker rm/rmi CONTAINER_ID/IMAGE_ID删除容器, 镜像 docker inspect CONTAINER_ID/IMAGE_ID查看细节信息 docker top CONTAINER_ID查看指定的运行容器的进程情况 docker info查看系统配置信息 docker save/load保存, 恢复镜像信息 docker commit CONTAINER_ID从容器创建镜像 docker export &gt; xxx.tar保存一个容器 docker import - &lt; xxx.tar恢复一个容器 docker cp CONTAINER_ID:PATH HOSTPATH从镜像复制文件到实体机 docker diff CONTAINER_ID查看容器相对于镜像的文件变化 docker logs CONTAINER_ID查看容器日志 docker build从Dockerfile 构建镜像 docker history IMAGE_ID查看镜像的构建历史 docker system prune清理所有停止的容器、至少一个容器未使用的所有网络、所有悬空的镜像、所有悬而未决的构建缓存 docker system prune -a清理所有停止的容器、至少一个容器未使用的所有网络、没有至少一个容器关联的所有镜像、所有悬而未决的构建缓存 常用命令分类 一、基本命令 docker version 查看docker版本 docker info 查看docker详细信息 docker --help 查看docker命令 二、镜像命令 docker images查看docker镜像 PEPOSITORY：镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 同一个仓库源可以有多个TAG，表示这个仓库源的不同版本，我们使用REPOSITORY:TAG来定义不同的镜像。如果不指定一个镜像的版本标签，例如只使用tomcat，docker将默认使用tomcat:latest镜像 docker images -a列出本地所有的镜像 docker images -p只显示镜像ID docker images --digests显示镜像的摘要信息 docker images --no-trunc显示完整的镜像信息 docker search tomcat从Docker Hub上查找tomcat镜像，STARS：关注度 docker search -s 30 tomcat从Docker Hub上查找关注度大于30的tomcat镜像 docker pull tomcat从Docker Hub上下载tomcat镜像。等价于：docker pull tomcat:latest docker commit -m &quot;提交的描述信息&quot; -a &quot;作者&quot; 容器ID 要创建的目标镜像名称:[标签名]提交容器使之成为一个新的镜像。 如： docker commit -m &quot;新的tomcat&quot; -a &quot;lizq&quot; f9e29e8455a5 mytomcat:1.2 docker rmi hello-world从Docker中删除hello-world镜像 docker rmi -f hello-world从Docker中强制删除hello-world镜像 docker rmi -f hello-world nginx从Docker中强制删除hello-world镜像和nginx镜像 docker rmi -f $(docker images -p)通过docker images -p查询到的镜像ID来删除所有镜像 三、容器命令 docker run [OPTIONS] IMAGE根据镜像新建并启动容器。IMAGE是镜像ID或镜像名称 OPTIONS说明： --name=“容器新名字”：为容器指定一个名称 -d：后台运行容器，并返回容器ID，也即启动守护式容器 -i：以交互模式运行容器，通常与-t同时使用 -t：为容器重新分配一个伪输入终端，通常与-i同时使用 -P：随机端口映射 -p：指定端口映射，有以下四种格式： ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort docker ps列出当前所有正在运行的容器 docker ps -a列出所有的容器 docker ps -l列出最近创建的容器 docker ps -n 3列出最近创建的3个容器 docker ps -q只显示容器ID docker ps --no-trunc显示当前所有正在运行的容器完整信息 exit退出并停止容器 Ctrl+p+q只退出容器，不停止容器 docker start 容器ID或容器名称启动容器 docker restart 容器ID或容器名称重新启动容器 docker stop容器ID或容器名称停止容器 docker kill 容器ID或容器名称强制停止容器 docker rm 容器ID或容器名称删除容器 docker rm -f 容器ID或容器名称强制删除容器 docker rm -f $(docker ps -aq)删除多个容器 docker logs -f -t --since --tail 容器ID或容器名称查看容器日志 如： docker logs -f -t --since=”2018-09-10” --tail=10 f9e29e8455a5 -f : 查看实时日志 -t : 查看日志产生的日期 --since : 此参数指定了输出日志开始日期，即只输出指定日期之后的日志 --tail=10 : 查看最后的10条日志 docker top 容器ID或容器名称查看容器内运行的进程 docker inspect 容器ID或容器名称查看容器内部细节 docker attach 容器ID进到容器内 docker exec 容器ID进到容器内 docker cp 容器ID:容器内的文件路径 宿主机路径从容器内拷贝文件到宿主机. 如： docker cp f9e29e8455a5:/tmp/yum.log /root ","link":"https://youngyuan1971.github.io/post/Docker基本命令/"},{"title":"文件分享CHFS基本用法","content":"非系统服务运行 该程序是一个控制台程序，可直接双击运行，或在控制台/命令行中运行。可通过命令行参数进行相关配置，如使用'chfs --help'来查看帮助： usage: chfs.exe [] Flags: --help Show context-sensitive help (also try --help-long and --help-man). --path=DIRECTORIES Directories where store shared files, separated by '|'. --port=PORT HTTP listening port(Default is 80). --allow=LIST Allowed IPv4 addresses(Allow any address by default). White list mode: &quot;listitem1[,listitem2,...]&quot; e.g. &quot;192.168.1.2-192.168.1.10,192.169.1.222&quot; allows this 10 addresses. Black list mode: &quot;not(listitem1[,listitem2,...])&quot; e.g. &quot;not(192.168.1.2-192.168.1.10,192.169.1.222)&quot; bans this 10 addresses! --rule=LIST Access rules(anybody can access any thing by default). List defines like:&quot;USER:PWD:MASK[:DIR:MASK...][|...]&quot;: 1,USER and PWD is account name and password 2,MASK:''=NO present,'r'=read,'w'=write,'d'=delete 3,r=view+download,w=r+upload+create+rename,d=w+delete 4,DIR is directory name, allows wildcard('*' &amp; '?') 5,The 3rd field is access mask of shared root directory 6,The optional fields is pairs of sub-directory and mask 7,The optional sub-directory's mask overwrite parent's 8,You should avoid '|' ':' and white space(exclude DIR) For instance: &quot;::|root:123456:rw&quot; bans guest, and defines a account 'root' can do anything --log=DIRECTORY Log directory. Empty value will disable log. --file=FILE A configuration file which overwrites &amp; enhence the settings. --version Show application version. 参数说明： help:显示帮助信息path:你要共享的目录，默认为程序运行目录。如果需要共享多个目录，则用“|”符号隔开。注意：如果路径带有空格，则需要将整个路径用引号包住。port:程序使用的端口号，默认为80allow:IP地址过滤，可使用白名单模式或黑名单模式rule:账户及访问权限，允许一个账户多点登陆，默认情况下匿名用户具有读写权限，其语法为：RULEITEM1[|RULEITEM2|RULEITEM3...]每个RULEITEM代表一个账户信息及其访问权限，多个RULEITEM则用'|'进行分割，RULEITEM的语法为：USER:PWD:MASK[:DIR:MASK...]每个项由“:”来分隔，前三个项是必须的，分别对应：账户名、账户密码、共享目录根目录的访问权限。后面的可选的项，必须成对出现，用来设定根目录下面的子级目录的访问权限。一些规定：* 对于匿名用户，前两个项都为空* 访问权限分为四种：\"\"(不可访问)，\"R\"(只读)，\"W\"(读写)，\"D\"(写+删除)。读权限指的是下载，写权限指上传、新建等操作，删除权限是在写权限的基础上加上删除权限。* 各项的值应避免出现空白键，':'及'|'（目录名除外）log:用户操作日志存放目录，默认是程序所在目录下的logs中。禁用日志功能只需将其赋值为空即可。file:配置文件，该文件可配置上述配置项，语法相同，如果配置有效则覆盖对应配置项。另外，一些功能需要通过配置文件进行配置，比如页面自定义和SSL证书设置。下载配置文件模板version:显示程序版本号 几个例子： //都使用默认参数，共享目录为程序运行目录，监听端口号为80 chfs //共享目录为D盘，监听端口号为8080 chfs --path=&quot;d:/&quot; --port=8080 //共享目录为&quot;d:\\\\projects&quot;和&quot;e:\\\\nsis&quot;，监听端口号为80 chfs --path=&quot;d:\\\\projects|e:\\\\nsis&quot; //白名单模式，允许192.168.1.2-192.168.1.100以及192.168.1.200进行访问 chfs --allow=&quot;192.168.1.2-192.168.1.100,192.168.1.200&quot; //黑名单模式，禁止192.168.1.2-192.168.1.100以及192.168.1.200进行访问 chfs --allow=&quot;not(192.168.1.2-192.168.1.100,192.168.1.200)&quot; //匿名用户具有只读权限（默认情况下匿名用户具有读写权限） //账户ceshizu，密码为ceshizu123，对根目录的权限为只读，但对test目录具有读写权限 //账户yanfazu，密码为yanfazu123，对根目录的权限为只读，但对yanfa目录具有读写权限 chfs --rule=&quot;::r|ceshizu:ceshizu123:r:test:rw|yanfazu:yanfazu123:r:yanfa:rw&quot; //匿名用户什么权限都没有（默认情况下匿名用户具有读写权限） //账户admin，密码为admin123，具有读写权限 //账户zhangsan，密码为zhangsan123，对根目录的权限为不可读写，但对zhangsanfiles目录具有读写权限 chfs --rule=&quot;::|admin:admin123:rw|zhangsan:zhangsan123::zhangsanfiles:rw&quot; //通过配置文件进行配置，该文件可以不存在，待以后需要更改配置时使用 chfs --file=&quot;d:\\chfs\\chfs.ini&quot; Tips 1：在Windows系统中，可以使用右键弹出菜单快捷地共享某个目录。步骤如下： 下载注册表模板文件 在该文件中编辑你的chfs.exe的真实路径，并可添加其他参数 双击该脚本文件，进行注册表添加 Tips 2：另外，有几个功能需要通过配置文件中进行配置，其中主要的配置项有： html.title： 自定义网页标题 html.notice: 自定义网页顶部的公告板。可以是文字，也可以是HTML标签，此时，需要适用一对``(反单引号，通过键盘左上角的ESC键下面的那个键输出)来包住所有HTML标签 ssl.cert和ssl.key: 用来配置SSL，启用HTTPS folder.leaf.download: 仅最后一个目录可以打包下载 session.timeout: 会话的时长，单位是分钟 以系统服务运行 本程序不是一个服务程序，所以如果你要以系统服务运行，需要自己创建服务。下面给出Windows平台的创建服务方法(通过NSSM工具)： 将chfs.exe放在指定目录，假设为：d:\\program\\cutehttpfileserver 到http://www.nssm.cc/download下载nssm 将解压后的nssm程序放在d:\\program\\cutehttpfileserver中 在d:\\program\\cutehttpfileserver中运行命令行，或运行命令行并CD至该目录 假设你的服务名称为cute_http_file_service，命令行中输入：nssm install cute_http_file_service NSSM会弹出配置对话框，在该对话框中输入程序路径以及运行参数 启动服务，命令行中输入：nssm start cute_http_file_service 配置文件中有ssl.cert和ssl.key两个键值，设置好对应的文件目录即可。另外，chfs支持的最低SSL版本为SSLv3，不兼容SSL2的握手。对了，别忘了将监听端口设置为443 ","link":"https://youngyuan1971.github.io/post/文件分享CHFS基本用法/"},{"title":"Docker部署Django项目","content":"如果您只想使用 Docker 命令行，而不使用 Docker Compose 来部署 Django 项目并使用 SQLite 数据库，可以按照以下步骤操作： 创建 Dockerfile 文件 在项目根目录下创建一个名为 Dockerfile 的文件，并添加以下内容： # 基于 Python 3.9 镜像构建 FROM python:3.9 # 设置工作目录 WORKDIR /app # 复制项目文件到容器中 COPY . /app # 安装项目所需的依赖 RUN pip install -r requirements.txt # 运行 Django 项目 CMD python manage.py runserver 0.0.0.0:8000 创建 requirements.txt 文件 确保您的 Django 项目根目录中存在一个名为 requirements.txt 的文件，其中包含项目所需的所有 Python 依赖包。 在项目根目录（并在项目虚拟环境下），输入以下代码： pip freeze &gt; requirements.txt 创建 Docker 镜像 打开终端，并导航到项目根目录。 使用以下命令来构建 Docker 镜像： docker build -t django-app . 这将自动寻找Dockerfile，在当前目录中构建一个名为 django-app 的 Docker 镜像。 运行 Docker 容器 构建完成后，可以使用以下命令来运行 Docker 容器： docker run --name=&quot;my_django_project&quot; -p 8000:8000 -v $(pwd):/app django-app 这将启动一个名为 my_django_project 的容器，并将容器的 8000 端口映射到主机的 8000 端口。同时，该命令还将当前目录挂载到容器的 /app 目录，以便在开发过程中能够实时更新代码。 从浏览器访问项目 在浏览器中访问 http://localhost:8000，即可查看部署的 Django 项目。 通过这些步骤，您可以使用 Docker 命令行将 Django 项目部署到 Docker 中，并使用 SQLite 数据库。 ","link":"https://youngyuan1971.github.io/post/Docker部署Django项目/"},{"title":"Python库--Faker包的使用","content":" 使用Faker这个Python库，用它可以生成批量的各种伪数据。 安装包 pip install Faker 初始化 导入包 from faker import Faker # 1 fake = Faker() # 2 fake.name() # 3 # Donna Kelly fake.address() # 4 # 519 Donna River # Port Natalie, SD 87384 1. 从faker模块导入Faker这个类。 2. 实例化对象，保存到变量fake中。 3. 调用name()方法随机生成一个名字。 4. 调用address()方法随机生成地址信息。 设置区域 如果要生成中文的随机数据，我们可以在实例化时给locale参数传入‘zh_CN’这个值 from faker import Faker fake = Faker(locale='zh_CN') fake.name() # 庞超 fake.address() # 河北省辛集县合川张街p座 489476 如果要生成中文繁体字，则可以传入中国台湾这个地区的值'zh_TW'(当然地址显示的是台湾的) from faker import Faker fake = Faker(locale='zh_TW') fake.name() # 羅婉婷 fake.address() # 16934 大里縣水源巷35號之0 如果要生成其他语种或地区的数据，可以传入相应的地区值 Region locale Region locale Arabic (Egypt) ar_EG Arabic (Palestine) ar_PS Arabic (Saudi Arabia) ar_SA Bulgarian bg_BG Bosnian bs_BA Czech cs_CZ German de_DE Danish dk_DK Greek el_GR English (Australia) en_AU English (Canada) en_CA English (Great Britain) en_GB English (New Zealand) en_NZ English (United States) en_US Spanish (Spain) es_ES Spanish (Mexico) es_MX Estonian et_EE Persian (Iran) fa_IR Finnish fi_FI French fr_FR Hindi hi_IN Croatian hr_HR Hungarian hu_HU Armenian hy_AM Italian it_IT Japanese ja_JP Georgian (Georgia) ka_GE Korean ko_KR Lithuanian lt_LT Latvian lv_LV Nepali ne_NP Dutch (Netherlands) nl_NL Norwegian no_NO Polish pl_PL Portuguese (Brazil) pt_BR Portuguese (Portugal) pt_PT Romanian ro_RO Russian ru_RU Slovene sl_SI Swedish sv_SE Turkish tr_TR Ukrainian uk_UA Chinese (China Mainland) zh_CN Chinese (China Taiwan) zh_TW 使用方法 注：个别方法具有针对性，比如province()方法适用中国，但不适用美国及其他一些国家。 地址相关 fake.address() # 地址 # '香港特别行政区大冶县上街钟街k座 664713' fake.building_number() # 楼名 # 'v座' fake.city() # 完整城市名 # '长春县' fake.city_name() # 城市名字(不带市县) # '梧州' fake.city_suffix() # 城市后缀名 # '市' fake.country() # 国家名称 # '厄立特里亚' fake.country_code(representation=&quot;alpha-2&quot;) # 'BZ' # 国家编号 fake.district() # 地区 # '沙湾' fake.postcode() # 邮编 # '332991' fake.province() # 省 # '河北省' fake.street_address() # 街道地址 # '武汉街D座' fake.street_name() # 街道名称 # '广州路' fake.street_suffix() # 街道后缀名 # '路' 汽车相关 fake.license_plate() # 牌照 # 'ZCO 000' 银行相关 fake.bank_country() # 银行所属国家 # 'GB' fake.bban() # 基本银行账号 # 'TPET9323218579379' fake.iban() # 国际银行代码 # 'GB82IRVM1531009974701' 条形码相关 fake.ean(length=13) # EAN条形码 # '5456457843465' fake.ean13() # EAN13条形码 # '2689789887590' fake.ean8() # EAN8条形码 # '52227936' 颜色相关 fake.color_name() # 颜色名称 # 'Orange' fake.hex_color() # 颜色十六进制值 # '#a5cb7c' fake.rgb_color() # 颜色RGB值 # '15,245,42' fake.rgb_css_color() # CSS颜色值 # 'rgb(15,70,13)' fake.safe_color_name() # 安全色 # 'aqua' fake.safe_hex_color() # 安全色十六进制值 # '#881100' 公司相关 fake.bs() # 商业用词 # 'synthesize strategic vortals' fake.catch_phrase() # 妙句(口号) # 'Robust even-keeled service-desk' fake.company() # 公司名称 # '富罳科技有限公司' fake.company_prefix() # 公司名称前缀 # '商软冠联' fake.company_suffix() # 公司名称后缀 # '网络有限公司' 信用卡相关 fake.credit_card_expire(start=&quot;now&quot;, end=&quot;+10y&quot;, date_format=&quot;%m/%y&quot;) # 过期年月 # '11/20' fake.credit_card_full(card_type=None) # 完整信用卡信息 # 'VISA 16 digit\\n秀珍 卢\\n4653084445257690 11/19\\nCVC: 935\\n' fake.credit_card_number(card_type=None) # 信用卡卡号 # '4339481813664365360' fake.credit_card_provider(card_type=None) # 信用卡提供商 # 'VISA 19 digit' fake.credit_card_security_code(card_type=None) # 信用卡安全码 # '597' 货币相关 fake.cryptocurrency() # 加密货币代码+名称 # ('TRX', 'TRON') fake.cryptocurrency_code() # 加密货币代码 # 'MZC' fake.cryptocurrency_name() # 加密货币名称 # 'Ripple' fake.currency() # 货币代码+名称 # ('GNF', 'Guinean franc') fake.currency_code() # 货币代码 # 'SOS' fake.currency_name() # 货币名称 # 'Lebanese pound' 时间相关 fake.am_pm() # AM或PM # 'PM' fake.century() # 世纪 # 'XII' fake.date(pattern=&quot;%Y-%m-%d&quot;, end_datetime=None) # 日期字符串(可设置格式和最大日期) # '1998-05-13' fake.date_between(start_date=&quot;-30y&quot;, end_date=&quot;today&quot;) # 日期(可设置限定范围) # datetime.date(2014, 8, 17) fake.date_between_dates(date_start=None, date_end=None) # 同上 # datetime.date(2019, 10, 14) fake.date_object(end_datetime=None) # 日期(可设置最大日期) # datetime.date(1981, 12, 20) fake.date_of_birth(tzinfo=None, minimum_age=0, maximum_age=115) # 出生日期 # datetime.date(1931, 12, 8) fake.date_this_century(before_today=True, after_today=False) # 本世纪日期 # datetime.date(2003, 5, 4) fake.date_this_decade(before_today=True, after_today=False) # 本年代中的日期 # datetime.date(2014, 1, 29) fake.date_this_month(before_today=True, after_today=False) # 本月中的日期 # datetime.date(2019, 10, 10) fake.date_this_year(before_today=True, after_today=False) # 本年中的日期 # datetime.date(2019, 3, 6) fake.date_time(tzinfo=None, end_datetime=None) # 日期和时间 # datetime.datetime(1990, 8, 11, 22, 25) fake.date_time_ad(tzinfo=None, end_datetime=None, start_datetime=None) # 日期和时间(从001年1月1日到现在) # datetime.datetime(244, 12, 17, 9, 59, 56) fake.date_time_between(start_date=&quot;-30y&quot;, end_date=&quot;now&quot;, tzinfo=None) # 日期时间(可设置限定范围) # datetime.datetime(1995, 4, 19, 17, 23, 51) fake.date_time_between_dates(datetime_start=None, datetime_end=None, tzinfo=None) # 同上 # datetime.datetime(2019, 10, 14, 14, 15, 36) fake.date_time_this_century(before_now=True, after_now=False, tzinfo=None) # 本世纪中的日期和时间 # datetime.datetime(2009, 8, 26, 18, 27, 9) fake.date_time_this_decade(before_now=True, after_now=False, tzinfo=None) # 本年代中的日期和时间 # datetime.datetime(2019, 2, 24, 22, 18, 44) fake.date_time_this_month(before_now=True, after_now=False, tzinfo=None) # 本月中的日期和时间 # datetime.datetime(2019, 10, 3, 9, 20, 44) fake.date_time_this_year(before_now=True, after_now=False, tzinfo=None) # 本年中的日期和时间 # datetime.datetime(2019, 2, 10, 7, 3, 18) fake.day_of_month() # 几号 # '23' fake.day_of_week() # 星期几 # 'Tuesday' fake.future_date(end_date=&quot;+30d&quot;, tzinfo=None) # 未来日期 # datetime.date(2019, 10, 28) fake.future_datetime(end_date=&quot;+30d&quot;, tzinfo=None) # 未来日期和时间 # datetime.datetime(2019, 10, 28, 21, 4, 35) fake.iso8601(tzinfo=None, end_datetime=None) # iso8601格式日期和时间 # '1995-04-10T00:45:01' fake.month() # 第几月 # '07' fake.month_name() # 月份名称 # 'December' fake.past_date(start_date=&quot;-30d&quot;, tzinfo=None) # 过去日期 # datetime.date(2019, 10, 3) fake.past_datetime(start_date=&quot;-30d&quot;, tzinfo=None) # 过去日期和时间 # datetime.datetime(2019, 9, 30, 20, 25, 43) fake.time(pattern=&quot;%H:%M:%S&quot;, end_datetime=None) # 时间(可设置格式和最大日期时间) # '14:26:44' fake.time_delta(end_datetime=None) # 时间间隔 # datetime.timedelta(0) fake.time_object(end_datetime=None) # 时间(可设置最大日期时间) # datetime.time(4, 41, 39) fake.time_series(start_date=&quot;-30d&quot;, end_date=&quot;now&quot;, precision=None, distrib=None, tzinfo=None) # &lt;generator object Provider.time_series at 0x7fadf51e0930&gt; fake.timezone() # 时区 # 'Asia/Baku' fake.unix_time(end_datetime=None, start_datetime=None) # UNIX时间戳 # 393980728 fake.year() # 某年 # '2016' 文件相关 fake.file_extension(category=None) # 文件扩展名 # 'avi' fake.file_name(category=None, extension=None) # 文件名 # '专业.pptx' fake.file_path(depth=1, category=None, extension=None) # 文件路径 # '/的话/以上.ods' fake.mime_type(category=None) # MIME类型 # 'application/xop+xml' fake.unix_device(prefix=None) # UNIX设备 # '/dev/xvdq' fake.unix_partition(prefix=None) # UNIX分区 # '/dev/xvdc6' 坐标相关 fake.coordinate(center=None, radius=0.001) # 坐标 # Decimal('147.543284') fake.latitude() # 纬度 # Decimal('66.519139') fake.latlng() # 经纬度 # (Decimal('55.3370965'), Decimal('-15.427896')) fake.local_latlng(country_code=&quot;US&quot;, coords_only=False) # 返回某个国家某地的经纬度 # ('25.67927', '-80.31727', 'Kendall', 'US', 'America/New_York') fake.location_on_land(coords_only=False) # 返回地球上某个位置的经纬度 # ('42.50729', '1.53414', 'les Escaldes', 'AD', 'Europe/Andorra') fake.longitude() # 经度 # Decimal('70.815233') 网络相关 fake.ascii_company_email(*args, **kwargs) # 企业邮箱(ascii编码) # 'qiuyan@xiulan.cn' fake.ascii_email(*args, **kwargs) # 企业邮箱+免费邮箱(ascii编码) # 'lei59@78.net' fake.ascii_free_email(*args, **kwargs) # 免费邮箱(ascii编码) # 'pcheng@gmail.com' fake.ascii_safe_email(*args, **kwargs) # 安全邮箱(ascii编码) # 'fangyan@example.org' fake.company_email(*args, **kwargs) # 企业邮箱 # 'scao@pingjing.net' fake.domain_name(levels=1) # 域名 # 'dy.cn' fake.domain_word(*args, **kwargs) # 二级域名 # 'gangxiuying' fake.email(*args, **kwargs) # 企业邮箱+免费邮箱 # 'na13@ding.cn' fake.free_email(*args, **kwargs) # 免费邮箱 # 'fang48@hotmail.com' fake.free_email_domain(*args, **kwargs) # 免费邮箱域名 # 'yahoo.com' fake.hostname(*args, **kwargs) # 主机名 # 'lt-70.53.cn' fake.image_url(width=None, height=None) # 图片URL # 'https://placekitten.com/752/243' fake.ipv4(network=False, address_class=None, private=None) # ipv4 # '160.152.149.78' fake.ipv4_network_class() # ipv4网络等级 # 'b' fake.ipv4_private(network=False, address_class=None) # 私有ipv4 # '10.99.124.57' fake.ipv4_public(network=False, address_class=None) # 公共ipv4 # '169.120.29.235' fake.ipv6(network=False) # ipv6 # 'f392:573f:d60f:9aed:2a4c:36d7:fe5b:7034' fake.mac_address() # MAC地址 # '62:67:79:8c:c2:40' fake.safe_email(*args, **kwargs) # 安全邮箱 # 'jing58@example.org' fake.slug(*args, **kwargs) # URL中的slug # '' fake.tld() # 顶级域名 # 'cn' fake.uri() # URI # 'http://yi.com/list/main/explore/register.php' fake.uri_extension() # URI扩展 # '.php' fake.uri_page() # URI页 # 'terms' fake.uri_path(deep=None) # URI路径 # 'blog/tags/blog' fake.url(schemes=None) # URL # 'http://liutao.cn/' fake.user_name(*args, **kwargs) # 用户名 # 'xiulan80' 图书相关 fake.isbn10(separator=&quot;-&quot;) # ISBN-10图书编号 # '0-588-73943-X' fake.isbn13(separator=&quot;-&quot;) # ISBN-13图书编号 # '978-1-116-51399-8' 文本相关 fake.paragraph(nb_sentences=3, variable_nb_sentences=True, ext_word_list=None) # 单个段落 # '最新事情生产.方面解决名称责任而且.类型其实内容发生电脑.音乐具有今年是一.' fake.paragraphs(nb=3, ext_word_list=None) # 多个段落 # ['使用评论管理.没有广告工作评论是否.', '帖子而且专业.这些比较完全发现准备设计工具.', '完成详细发生空间汽车.新闻电影您的游戏这种操作网站知道.'] fake.sentence(nb_words=6, variable_nb_words=True, ext_word_list=None) # 单个句子 # '直接这样点击单位对于时候.' fake.sentences(nb=3, ext_word_list=None) # 多个句子 # ['电话国际项目管理.', '软件之后提高一样次数电影规定.', '东西会员发展什么不断经济.'] fake.text(max_nb_chars=200, ext_word_list=None) # 单个文本 # ('资源信息得到因此开发资源资料.\\n' # '国家这样等级需要用户如此.电话非常一切游戏所以学校类型.不要正在如果来源认为投资在线.\\n' # '这些更新密码其中起来实现有些.以上事情重要通过.\\n' # '但是就是介绍最大深圳简介设计.历史这种可以出现中心社区.\\n' # '政府当然包括简介全国内容生活.有些地址以上.回复这些来自搜索现在不断经营不断.\\n' # '操作为什孩子报告东西拥有如此.相关特别业务日本这种.合作问题准备比较谢谢.') fake.texts(nb_texts=3, max_nb_chars=200, ext_word_list=None) # 多个文本 # [ '地址控制无法正在必须中心积分一些.支持制作安全.\\n' # '比较最新最大她的功能能够是一.主题选择当前显示.\\n' # '的话社会现在地区阅读继续所有.美国数据正在深圳不能.\\n' # '能够查看其中生活商品.谢谢认为之后以及以下之后这里.\\n' # '活动支持人民这么今年.要求包括生活运行技术社会.\\n' # '当前更多游戏.下载一点开发论坛法律为了美国.\\n' # '如何更新个人谢谢作为还有论坛.销售销售法律学生这么责任一些.', # '日本最大方法活动主题到了结果.教育还有孩子觉得简介出现国际.东西国家图片威望品牌.\\n' # '那些会员现在准备可能.威望部分文件主题东西业务一切之间.所以必须当前方法.\\n' # '等级大小重要可能下载孩子.来源感觉业务文件以后深圳学校.网络什么新闻都是安全.\\n' # '资料重要成功谢谢时候音乐安全相关.电脑系列日期.工具使用搜索来源首页.\\n' # '直接企业影响大小什么.相关品牌选择她的规定来源推荐.', # '中文文化数据内容系统.他们这些之间深圳.\\n' # '联系城市出现部分都是政府生活.社会同时人民市场现在决定需要.其他政府简介深圳教育加入对于.\\n' # '运行是一语言安全通过大小学生.商品然后信息由于虽然.\\n' # '因为关于选择希望行业具有深圳.出现价格那么下载提高知道人员.设备直接显示事情帖子正在两个关于.\\n' # '系列公司大家.论坛所以完全文章标准.活动中国工具电脑.\\n' # '主题作者不能.进行国家系统地区增加.经验质量价格我的.'] fake.word(ext_word_list=None) # 单个词语 # '新闻' fake.words(nb=3, ext_word_list=None, unique=False) # 多个词语 # ['选择', '历史', '规定'] 编码相关 fake.binary(length=1048576) # 二进制 # (b'\\xbf\\xce\\x01Y:\\xf7\\xf4\\xe0G]\\x94*Rb\\x9f\\x85\\xb6\\xcd\\x83\\x15\\t\\xbc\\x16\\x8d' # b'\\xcb\\n\\x90\\x10S\\x1e85\\x91\\xae\\x06\\xbdq.\\xf6c\\x1f\\xfd\\x94=\\\\\\xf9_\\xc2' # b't\\xe0{\\x15\\xd9\\x8fW7\\xe5[\\x0b\\x84\\xd2\\x94\\xf4\\xd91\\xd2\\x91\\x01\\xb5\\xeej\\x84' # b'*\\x81\\x96\\xa7\\xa9\\xda\\x1f\\xee\\x9a\\xb0\\x1d\\xef\\xad\\x92\\x1c\\x0f\\xa0U6\\xaf' # b'x5\\x9f\\x93\\\\b \\xf7kq\\xfe\\x97(\\xe0Q\\x89*\\xbb\\x8b\\x9a\\x14\\xd2\\xfe\\x07' # b'\\xfe\\xcfYy\\x16\\x12\\xef\\xe3\\xd9%\\x95\\\\\\x80O\\xec\\x9f\\xf7\\x88\\xfal' # b'\\x11\\x93\\x94\\xb1\\xd9\\xf6b\\xf0\\x7f\\xa2\\x95\\x93[\\x98\\xf3\\xe0$\\xdd\\xe0D' # b'\\xde\\x8c\\xe3\\xe0\\xc0f\\xab\\x1c\\xf6\\xdf]\\xbe8U\\x11\\xc7\\xce\\xf6f\\xc9' # b'1\\xa6\\xda\\x85\\xe6.\\xda\\xd1_\\x8a\\xbe\\x05\\xbf\\xf4*x [\\xb9\\xc3\\xbb\\x99\\xa1\\xbe' # b'GT\\xb75\\x96\\x8a\\x9a:`o\\x1bm\\xe9KzT\\x0c\\xdc\\xb1\\xe7ssiN\\xcb2\\x8eY' # b'\\xd1\\xb4\\x8c+\\xe9\\xc1Ph\\x0fD\\x0f\\xd5}\\n/K$\\x85J\\xaf\\x1d\\xb2\\xd0R\\xa7n0l' # b'\\xafQ\\x91\\x95\\xac]a\\xe1\\x8f\\x1f\\x9e`e\\xd2\\x1f\\xaa\\xeb\\xf3[}(\\xd60\\x01' # b'Y\\r\\xe2XCW\\xba\\xa3\\xad\\xe4OP\\x891=\\xff\\xae\\xb9\\x9d\\xa2!\\xfa2\\r\\x81\\xfat\\xfb' # b'3t%\\xd5\\x11B\\x94Os\\x8d\\xc5\\xae%\\xa6\\x93}[p\\x02\\xd7\\xba\\xa4\\xf0?R\\xbb\\xf6\\xb1' # b'h\\x12J\\x05\\xce\\xf9\\xcd\\xc6\\xa7\\xed\\x80\\x9e\\x9e\\xf8q]\\xab\\x9a\\xd7\\xd6' # b'\\xad\\xecK\\x1d=\\xb0?\\xb2\\x83\\t&lt;\\xb2ZGl\\x9f\\x8dmI\\x1d\\xf1jh\\xd3s\\x9d\\xd6\\xf9' # b'\\x8e\\xbfs\\xa9_\\xe0\\xaf\\x86O\\xde|\\x17\\xb5\\x8b\\xe4:Z\\xa1\\x01f\\xc9l[Z' # b'\\xb4\\x7fS\\x0f7\\x9c\\x9d\\xdd\\xd3PY\\x86\\xf4\\xec\\xcb\\x87\\x05\\xafU-\\xaebY~' # b&quot;\\x9f\\xec\\xf6\\x9c\\x84\\x99'S\\xd4\\t.\\xd0x\\xbb\\x01&lt;&amp;\\xdd\\xfc6M\\xa9|R&quot; # b'\\xec\\xf9b\\xcdz\\x9a\\x97p\\xb5\\xb6\\x13\\xd9\\xab\\x91C\\xe4\\x95\\xc9\\x18\\xaeAi\\\\N' # b&quot;#\\x99\\t+Z\\xd2\\xf1\\x89\\xa0L\\x04\\xef\\xaf&lt;\\xc4\\xfbO\\xcd\\x83\\xd4\\x17'C\\x10&quot; # b'\\x0b\\xd6\\xb5Cv\\x98}E\\xc9;\\xbf\\x05\\xab\\xc7 W\\xa8\\xbcmX\\x06\\x865\\xbe\\\\f\\xedc' # b'\\xacb\\xc8\\x84\\xc0KI\\xd5\\xea\\x888\\x93^\\xfcE\\xee,^(\\x97g\\xd17\\xcd8\\xabU\\x95' # b'\\x17~]\\x08\\x11\\xa4\\xbf\\xed\\xf3\\xabm\\x15l\\xde\\xf5\\x06c\\xe1\\xad+' # b'\\xed\\xd1\\xa5\\xda\\x15\\xbax\\xac}\\x8e\\xd7\\x8831\\x04\\xb3\\xae\\xc7\\xb4\\x04' # b'y\\xda!\\xeb\\x1e\\xcd\\n+\\x94#4\\xe51\\xc8\\xe9t\\n.:\\xfd\\xcfc\\x1a\\xcf\\x99VY\\x11' # b'Y\\x1bF\\xe9\\x9e\\xebK\\x86WD\\x80\\x12\\xf1\\x11z\\xf6\\xe3vV4\\xbcB\\n^k(\\x1aw' # b'&lt;\\xfd\\x95z\\t\\xf7\\xaa_F%n\\xc4\\xeb\\x94\\xcd\\x80\\xffh\\xbe{^\\x04\\xe3\\xe7' # b'\\xab\\xa3\\xd9\\x037\\x86\\xde~J\\x15th\\x98_\\xda\\xe25\\xeaO\\xc8\\x15\\xae\\xd7\\xa9' # b'\\x80\\x9as\\xef&lt;FU\\xb2\\x10\\x7fN\\x05\\x8dd_\\xef\\x0bQO-\\x9diW\\xdc\\xcdV\\xbe*' # b'\\x13\\xa7$\\x08\\xe4\\xb8\\x96bd\\xcf\\xe7\\xd6h\\xe9.{Z:S\\xef\\xc4\\x14R\\x91' # b&quot;\\xce\\xd3\\xcd\\xe3\\xbc\\x9f!Y\\x05A\\xa00\\x11\\xca\\xaa\\xeb\\xc4')\\xb3\\xdcF\\x8e\\xfa&quot; # b'\\xbd\\x9b:\\xae\\x1f\\xbe&lt;7]\\x93E\\xc2\\x1b\\x17\\xc95x\\x8f\\x88|\\xb8^\\xea\\x06' # b'(\\x9d\\xc5\\xeb\\x8a|\\x9f\\x05\\x83\\xfe\\xf5KsUy\\xdc\\xd1S\\x96\\xda\\xc5q\\xc4\\xfd' # b'\\xeb\\xc4&quot;\\x14Y\\x1cU\\x99\\xe8\\x11r\\x04\\x941\\xa1\\xac^c\\xbbG\\xc4\\xd8\\xb70' # b'\\xadX\\x98\\xad\\xf8\\xc1\\x11\\x10\\xbc\\x00\\x80\\x84\\x05\\x07b\\x8c0\\x93\\xe6\\xd8' # b'\\xe2I\\xea\\xecm+-\\x8aY\\xb8F\\x0e\\x19#zH{/\\xcb\\x88\\xac\\xa9\\xfe\\x84cH[_' # b'0d\\xc6\\xc4\\x0b\\r\\x9ef\\n\\xb3\\x97d\\xb4;\\xf1\\x014kv\\xd9h\\xad\\x18/\\xe6\\xf1r\\xa1' # b'3\\x9cz\\xf7\\x90\\r\\xaf\\xed\\x85\\x07\\x80\\xbb\\xc2\\x82\\xe4\\xcc\\x91\\xc8\\xdf\\x9a' # b'`St\\xd8\\x98\\xbb\\xac\\xe9\\x93\\xe0*\\xd7\\x9b/)\\x93\\x08\\xc1\\x0cxhD\\xd2\\xf1' # b'\\xbe5\\xe1\\x1f:\\x04\\x07\\xf1\\xb4\\xaeJ\\xe2\\xe0[\\x9e\\xa4\\x9b\\xed)\\xbf\\xc2}+\\x88' # b'\\x08I^f\\x82-\\xa2o\\xb2\\xc3\\x85\\xc5;Z\\x13B\\xf76~\\x9af\\xf7\\xa9\\x1a\\xa4\\xd4\\xb8b') fake.boolean(chance_of_getting_true=50) # 布尔值 # True fake.md5(raw_output=False) # Md5 # '0712ca7a3be00aa01c823de37dc61230' fake.null_boolean() # NULL+布尔值 # True fake.password(length=10, special_chars=True, digits=True, upper_case=True, lower_case=True) # 密码 # '^7cSoHR1^r' fake.sha1(raw_output=False) # SHA1 # 'f89f039d9fc00860651d9a567ac27990ae609445' fake.sha256(raw_output=False) # SHA256 # '675a85aa0d29583200f75351e35b4af0335af835fc617382cbd9fece258b6520' fake.uuid4(cast_to=&lt;class 'str'&gt;) # UUID4 # '0d7be36a-febd-4f9f-bf1e-791c0ee1227b' 人物相关 fake.first_name() # 名字 # '强' fake.first_name_female() # 名字(女) # '桂荣' fake.first_name_male() # 名字(男) # '志强' fake.first_romanized_name() # 名字(罗马文) # 'Chao' fake.last_name() # 姓 # '宋' fake.last_name_female() # 姓(女) # '陆' fake.last_name_male() # 姓(男) # '曾' fake.last_romanized_name() # 姓(罗马文) # 'Xie' fake.name() # 姓名 # '王凯' fake.name_female() # 姓名(女) # '戴丽丽' fake.name_male() # 姓名(男) # '刘荣' fake.prefix() # 称谓 # '' fake.prefix_female() # 称谓(女) # '' fake.prefix_male() # 称谓(男) # '' fake.romanized_name() # 称谓(罗马文) # 'Guiying Chang' fake.suffix() # 姓名后缀(中文不适用) # '' fake.suffix_female() # '' fake.suffix_male() # '' 职位相关 fake.job() # '客服专员/助理' 电话相关 fake.msisdn() # 完整手机号码(加了国家和国内区号) # '9067936325890' fake.phone_number() # 手机号 # '18520149907' fake.phonenumber_prefix() # 区号 # 145 档案相关 fake.profile(fields=None, sex=None) # 档案(完整) # { 'address': '河南省昆明市清河哈尔滨路H座 496152', # 'birthdate': datetime.date(2014, 11, 20), # 'blood_group': 'AB+', # 'company': '易动力信息有限公司', # 'current_location': (Decimal('77.504143'), Decimal('-167.365806')), # 'job': '培训策划', # 'mail': 'liangyang@yahoo.com', # 'name': '杨磊', # 'residence': '澳门特别行政区台北县西夏兴城街L座 803680', # 'sex': 'F', # 'ssn': '140722200004166520', # 'username': 'lei65', # 'website': [ 'http://www.29.cn/', # 'http://www.lei.cn/', # 'http://lishao.net/', # 'https://www.feng.net/']} fake.simple_profile(sex=None) # 档案(简单) # { 'address': '广西壮族自治区南宁市花溪孙街c座 653694', # 'birthdate': datetime.date(1993, 12, 16), # 'mail': 'haomin@yahoo.com', # 'name': '任秀英', # 'sex': 'F', # 'username': 'iding'} Python相关 fake.pybool() # Python布尔值 # False fake.pydecimal(left_digits=None, right_digits=None, positive=False, min_value=None, max_value=None) # Python十进制数 # Decimal('-837022273798.0') fake.pydict(nb_elements=10, variable_nb_elements=True, *value_types) # Python字典 # { '一种': 6381, # '可以': -9242847.69292, # '地址': 9668, # '拥有': 'jVBverSGAJvHsrcZPFDg', # '控制': Decimal('-98521.0'), # '本站': datetime.datetime(1983, 5, 30, 22, 51, 22), # '来源': 'MRTmgbdlwNlqHiIDUVTN', # '标题': 929, # '注册': 'QvYtlygVIopYPasYHCQr', # '解决': -7138575.3, # '问题': 1115.0} fake.pyfloat(left_digits=None, right_digits=None, positive=False, min_value=None, max_value=None) # Python浮点数 # 6.7442382094132 fake.pyint(min_value=0, max_value=9999, step=1) # Python整型值 # 8326 fake.pyiterable(nb_elements=10, variable_nb_elements=True, *value_types) # Python可迭代对象 # {'gang42@gmail.com', Decimal('-638462592926556.0'), 5383, 1608, 185608.962728, datetime.datetime(2013, 8, 7, 10, 44, 51), 'xvqHfWdLyTkaFoguvnqd', datetime.datetime(1999, 9, 10, 4, 41, 29), Decimal('4627589014.65023'), 'http://57.cn/category/', 'UZJwIrsLowvwVGAChwzB', Decimal('68.623476938'), 'mtUbDpTHnQAPVjXzknIM'} fake.pylist(nb_elements=10, variable_nb_elements=True, *value_types) # Python列表 # [ 589, # 'https://www.yangbai.cn/main/', # 'http://fang.cn/faq/', # 'HvtSTwWqDtughQLYibOd', # Decimal('-3541501.934427'), # 2758, # datetime.datetime(2018, 2, 22, 9, 51, 8), # 5375, # 'UVXMfCqJyZwBkfgGhQiH', # 'HfxybvRTPwaFmuhwvKLT', # Decimal('-21565647052012.8'), # 'wEqWsXKTputijSMWhCIb'] fake.pyset(nb_elements=10, variable_nb_elements=True, *value_types) # Python集合 # {7105, 'sidMFYVhXjkNZnHHimJJ', 'yexiuying@kw.cn', 'GPxoyEYixUGAoRCiEmDe', datetime.datetime(2001, 6, 17, 12, 49, 57), 'vOsPAdmmCmkJxeBUpBJP', -75011.0} fake.pystr(min_chars=None, max_chars=20) # Python字符串 # 'NOlWELuogcxSfRjYauSV' fake.pystruct(count=10, *value_types) # Python结构 # ( [ 'SQeHWPNdooccsfbZslee', # 'nDXibfaPXSpmIpxtDUWP', # 'DrZHepzMfNPRrxgcXwvR', # 988.956374402, # 7239, # 4885, # datetime.datetime(1972, 6, 13, 14, 18, 11), # -582284.9732, # datetime.datetime(1997, 8, 23, 9, 19, 6), # 'http://www.hu.cn/homepage.php'], # { '一般': 'oqUQKBhqNylyofEditXs', # '不要': 'qTlztJembuRZHFEzZnGO', # '价格': -2100690667.387, # '国内': datetime.datetime(1989, 9, 3, 11, 27, 11), # '密码': 'aWaufuJAzfgeuhyXAwDL', # '开发': 'aJvNisEMynJcAPhbNAHa', # '方法': 'WVEqHUnnkpUbAnllUqKL', # '汽车': 'bfQlaULiNfjgkrqQUCnL', # '用户': 'WDYNlInLyCcIXMFgyLDS', # '那个': 'qWivpUnOcTwGDhOXihOb'}, # { '个人': { 1: 'http://www.ik.cn/categories/tags/search/homepage/', # 2: [ 'gBSKOBAYYlPwILaWgory', # 'xoeueUWWgbvNHDxKYASD', # 'nkcelmDSpqiQasuKvNZg'], # 3: { 1: 2000, # 2: 'SeDZKUpCxrCLlrDIlPxV', # 3: [Decimal('7833105.737'), Decimal('-7.994')]}}, # '帖子': { 0: 'HXTKojcilYqgYmFUMjuk', # 1: [6887, 3635, 'http://hezhu.com/list/main/terms.html'], # 2: { 0: 'hkong@fujiang.cn', # 1: 4676, # 2: ['JYEFavcRqcsdpnSMwENU', 'vxu@gmail.com']}}, # '应该': { 7: 'EmzzdZrmUpIetxPktXAU', # 8: [ Decimal('4786692875733.0'), # datetime.datetime(2016, 10, 11, 10, 38, 20), # 'ghtelDQAsBeYDaokgbYg'], # 9: { 7: 'yanding@yahoo.com', # 8: 'dtjdazSyZCStWkVYwIvK', # 9: ['TPTzKNGReDCJmrfTkKmd', 'TKQmVfrNRioICuqCrrDQ']}}, # '我的': { 3: 'http://17.cn/home/', # 4: [ 'https://www.guiyingsu.cn/category/', # 'gweRIERFoojbKxRiiliG', # 'dMjUNjDRCSpdrNAlHXRp'], # 5: { 3: 'YeIsIoVHcIgAQWYZkQiR', # 4: 'hGDzyNMVafuDMXSbbhzY', # 5: [977, 'xCFBFdaPHNyFscSCqEWd']}}, # '或者': { 9: 'owgjdYQvTWZIZRewhkev', # 10: ['nHusiXLRunAMvynwjJgu', 6500, 'cQRHfcdFJGUyPDlIocqG'], # 11: { 9: 'sETogfbiwRIqFlrGXeiT', # 10: 'tliang@kong.cn', # 11: [ 'https://chaohao.cn/register.html', # 'fang21@yahoo.com']}}, # '技术': { 4: 8843, # 5: [-5660697068472.0, 7952, -52210308185.53], # 6: { 4: 6477, # 5: 8669, # 6: ['sGueDRKWFAtTExnruySP', 'YZcIHHkbDRLUgeHhblCu']}}, # '深圳': { 5: 2532, # 6: [ Decimal('66661967013036.0'), # 'lei14@yahoo.com', # 'https://www.fangyao.cn/categories/search.html'], # 7: { 5: datetime.datetime(1988, 9, 11, 2, 30, 1), # 6: 50.1, # 7: [ 'https://www.gang.cn/', # 'http://www.liao.cn/posts/app/main.html']}}, # '生产': { 2: 2187, # 3: [ 8629589.339, # 'QvftOABFsahZurjYIPTr', # 'GumqSZMuOSIfrUzjTzKO'], # 4: { 2: 1982, # 3: 'WatxfisQAelRTuwopoOA', # 4: ['xiacheng@00.cn', 'flrVEiuWlEnJjbxCazQG']}}, # '起来': { 6: 'luming@yahoo.com', # 7: [ 'http://www.yu.cn/home.php', # 'vvmhckwxQGnMCafhjXIA', # Decimal('-511928454.48')], # 8: { 6: 'https://www.naguiying.cn/', # 7: 279.928, # 8: [5034, 'shaochao@17.cn']}}, # '那么': { 8: 'PNrBODNdjLnhalWpVMXk', # 9: [ datetime.datetime(1973, 7, 4, 11, 42, 8), # 'iye@gmail.com', # 'iEPyTnfNhNhWWXbkStQC'], # 10: { 8: Decimal('-227034846260.0'), # 9: Decimal('616424892362.0'), # 10: [ 'AjpDMNozhUbedUuOZWdL', # datetime.datetime(1972, 10, 27, 8, 36, 39)]}}}) fake.pytuple(nb_elements=10, variable_nb_elements=True, *value_types) # Python元组 # ( Decimal('989085669.60574'), # 'yang44@hotmail.com', # 794, # datetime.datetime(1989, 12, 11, 4, 10, 40), # 234, # 'TyEwXywfUShjlUVwtMAk', # 'NLUdMSRYoBHmGGPhbwor', # -69.356824324) 身份证相关 fake.ssn(min_age=18, max_age=90) # 身份证 # '410622198603154708' 用户代理相关 fake.android_platform_token() # 安卓 # 'Android 5.0.1' fake.chrome(version_from=13, version_to=63, build_from=800, build_to=899) # Chrome # ('Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_10_9) AppleWebKit/534.0 (KHTML, ' # 'like Gecko) Chrome/62.0.826.0 Safari/534.0') fake.firefox() # FireFox # ('Mozilla/5.0 (Windows NT 5.1; cs-CZ; rv:1.9.0.20) Gecko/2010-12-02 06:14:30 ' # 'Firefox/3.6.5') fake.internet_explorer() # Ie # 'Mozilla/5.0 (compatible; MSIE 7.0; Windows 95; Trident/3.0)' fake.ios_platform_token() # ios # 'iPhone; CPU iPhone OS 5_1_1 like Mac OS X' fake.linux_platform_token() # Linux # 'X11; Linux i686' fake.linux_processor() # Linux处理器 # 'x86_64' fake.mac_platform_token() # Mac # 'Macintosh; U; PPC Mac OS X 10_11_2' fake.mac_processor() # Mac处理器 # 'Intel' fake.opera() # Opera # 'Opera/8.32.(Windows 98; Win 9x 4.90; mr-IN) Presto/2.9.188 Version/10.00' fake.safari() # Safari # ('Mozilla/5.0 (Windows; U; Windows NT 6.0) AppleWebKit/533.43.6 (KHTML, like ' # 'Gecko) Version/4.0.5 Safari/533.43.6') fake.user_agent() # 随机用户代理 # 'Mozilla/5.0 (compatible; MSIE 9.0; Windows 95; Trident/3.0)' fake.windows_platform_token() # Windows # 'Windows NT 6.2' ","link":"https://youngyuan1971.github.io/post/Python库--Faker包的使用/"},{"title":"Tampermonkey文档解析","content":"注释内容 @name 脚本的名字 @namespace 脚本的命名空间 @version 脚本的版本，用于检查更新。 脚本的作者 @description 简短重要的描述 @homepage, @homepageURL, @website and @source 在“选项”页上用于从脚本名链接到给定页的作者主页。请注意，如果@namespace标记以“http://”开头，则其内容也将用于此操作。 @icon, @iconURL and @defaulticon 低分率的脚本会在脚本管理列表上显示 @icon64 and @icon64URL 脚本icon 64*64 如果给了这个标签，但给了图标，则图标图像将在选项页的某些位置缩放 @updateURL 更新脚本的地址，注意：只有存在@version标签才会去更新 @downloadURL 定义检测到更新时将从中下载脚本的URL。如果值为none，则不会执行更新检查。 @supportURL 定义使用者报告issues和个人支持的地址 @include 脚本应该运行的页面， 可以使用正则匹配。 允许多个标签 请注意@include不支持url hash参数，可以访问这里获取更多的信息点击获取更多信息 示例 // @include http://www.tampermonkey.net/* // @include http://* // @include https://* // @include * @match 和@include标签差不多的意思， 你可以点击这里获取更多信息 注意： 尚不支持“”语句，scheme部分也接受“http*：//”。 允许多个标记实例。 @exclude 排除URL，即使它们包含在@include或@match中 。 允许多个标签 @require 指向一个脚本文件，会在本脚本运行前加载并执行 注意：通过@require加载的脚本及其“use strict”语句可能会影响用户脚本的strict模式！ 示例： // @require https://code.jquery.com/jquery-2.1.4.min.js // @require https://code.jquery.com/jquery-2.1.3.min.js#sha256=23456... // @require https://code.jquery.com/jquery-2.1.2.min.js#md5=34567...,sha256=6789... 有关如何确保完整性的详细信息，请查看子资源完整性部分。允许多个标记实例。 @resource 预加载可以通过脚本通过gm_getresourceurl和gm_getresourcetext访问的资源 示例 // @resource icon1 http://www.tampermonkey.net/favicon.ico // @resource icon2 /images/icon.png // @resource html http://www.tampermonkey.net/index.html // @resource xml http://www.tampermonkey.net/crx/tampermonkey.xml // @resource SRIsecured1 http://www.tampermonkey.net/favicon.ico#md5=123434... // @resource SRIsecured2 // http://www.tampermonkey.net/favicon.ico#md5=123434...;sha256=234234... 有关如何确保完整性的详细信息，请查看“子资源完整性”部分。允许多个标记实例。 @connect 此标记定义域（没有顶级域），包括允许由GM_xmlhttpRequest 检索的子域 示例 可以是以下几个值 域可以是: tampermokey.net (可以允许子域名) 子域名如: safari.tampermokey.net _self :_列出脚本当前运行的域 localhost 有权限访问localhost 1.2.3.4 链接到IP地址 * 如果无法声明用户脚本可能连接到的所有域，则最好执行以下操作： 声明所有已知或至少所有可能由脚本连接的公共域。这样，大多数用户都可以避免确认对话框。 另外在脚本中添加“@connect*”。通过这样做，tampermonkey仍然会询问用户是否允许下一个连接到未提及的域，但也会提供一个“总是允许所有域”按钮。如果用户单击此按钮，则将自动允许所有未来的请求。 用户还可以通过在“脚本设置”选项卡的用户域白名单中添加“*”来白名单所有请求。 注意： 初始url和最终的url都会被检查， 为了向后兼容scriptish@domain标记也会被解释。 允许多个标记实例。 @run-at 定义脚本被注入的时间，与其他脚本处理相反，@run-at 定义了脚本要运行的第一可能时间。 这意味着，使用**@require**标记的脚本可能会在文档已加载后执行，因为获取所需脚本花费了很长时间。无论如何，在给定的注入时刻之后发生的所有domnodeinserted和domcontentloaded事件都将被缓存，并在注入时传递给脚本。 全部示例: // @run-at document-start // 脚本会被尽可能快地注入 // @run-at document-body // 当body元素存在是被注入 // @run-at document-end // 当DOMContentLoaded事件被触发时或者之后注入 // @run-at document-idle // 当DOMContentLoaded事件被触发后被注入 如果没有@run-at标签也是在此时注入 // @run-at context-menu // 当点击浏览器上下文菜单时被注入（仅仅是桌面Chrome-based浏览器） // 注意：如果使用了context-menu @include和@exclude的变量都将被忽略，但是未来可能会改变 @grant @grant被用于设置GM_*函数的白名单， GM_*function 是一些unsafeWindow对象和一些有影响的window函数，如果没有@grant标签，TM会猜测脚本需要什么 示例： // @grant GM_setValue // @grant GM_getValue // @grant GM_setClipboard // @grant unsafeWindow // @grant window.close // @grant window.focus 由于关闭和聚焦选项卡是一个强大的功能，因此还需要将其添加到@grant语句中。 如果**@grant**后跟“none”，沙盒将被禁用，脚本将直接在页面上下文中运行。在此模式下，没有gm_u*函数，但gm_u info属性将可用。 示例 @noframes 这个标签表明脚本在主页面上运行，而不是在iframes里 @unwrap 这个标签是被忽略的，因为他在谷歌浏览器里不需要 @nocompat 目前，tm试图通过查找@match标记来检测脚本是否是在google chrome/chromium的知识中编写的，但并不是每个脚本都使用它。这就是为什么tm支持这个标签来禁用运行为firefox/greasemonkey编写的脚本所需的所有优化。要保持此标记可扩展，可以添加可由脚本处理的浏览器名称。 示例 应用程序接口（高级API） unsafeWindow unsafeWindow 对象提供权限访问页面的js函数和变量 Subresource Integrity(子资源完整性) 可以使用**@resource和@require**标记的url的散列组件来实现此目的。 示例： // @resource SRIsecured1 http://www.tampermonkey.net/favicon1.ico#md5=ad34bb... // @resource SRIsecured2 http://www.tampermonkey.net/favicon2.ico#md5=ac3434...,sha256=23fd34... // @require https://code.jquery.com/jquery-2.1.1.min.js#md5=45eef... // @require https://code.jquery.com/jquery-2.1.2.min.js#md5=ac56d...,sha256=6e789... TM本机支持MD5哈希作为回退，所有其他（SHA-1、SHA-256、SHA-384和SHA-512）都依赖于window.crypto。如果给定了多个散列（用逗号或分号分隔），则TM将使用当前支持的最后一个散列。如果外部资源的内容与所选哈希不匹配，则资源不会传递到用户脚本。所有散列都需要以十六进制或base64格式编码。 GM_addStyle(css) 给document添加样式，并且返回注入的节点 GM_deleteValue(name) 删除‘name’ 从storage里 GM_listValues() 列出storage中的所有name GM_addValueChangeListener(name, function(name, old_value, new_value, remote) {}) 在storage里添加一个改变事件的监听，并返回监听id ‘name’是被观察的变量 回调函数的‘remote’变量是显示此值是从另一个选项卡的实例修改的（true）还是在此脚本实例中修改的（false）。 因此，不同浏览器选项卡的脚本可以使用此功能相互通信。 可以使用此API实现不同浏览器Tab的相互通讯 GM_removeValueChangeListener(listener_id) 通过监听器的id移除一个监听改变的事件 GM_setValue(name, value) 设置‘name‘ 的值到storage中 GM_getValue(name, defaultValue) 从storage中获取‘name’的值 GM_log(message) 在控制台打印日志 GM_getResourceText(name) 获取在脚本顶部预定的@resource标签的内容 GM_getResourceURL(name) 获取在脚本顶部定义的@resource标签的base64 encodeURI GM_registerMenuCommand(name, fn, accessKey) 注册一个能在页面上能够显示TM菜单命令，当这个脚本执行是，并且返回菜单命令id 意思就是可以注册一个直接显示TM的菜单的ming GM_unregisterMenuCommand(menuCmdId) 取消注册一个菜单命令根据菜单命令ID(通过GM_registerMenuCommand 提供的) GM_openInTab(url, options), GM_openInTab(url, loadInBackground) 使用参数url打开一个新的tab，options可以是以下值 active 决定新的tab是否被聚焦，聚焦的意思是直接显示 insert 插入一个新的tab在当前的tab后面 setParent 在tab关闭后重新聚焦当前tab 另外，新的选项卡将被添加。loadinbackground具有与active相反的含义，并被添加以实现Greasemonkey 3.x兼容性。如果未指定“活动”或“加载后台”，则选项卡将不会聚焦。此函数返回一个具有函数close、侦听器onclosed和一个名为closed的标志的对象。 GM_xmlhttpRequest(details) 创建一个xmlHttpRequest. 参数**details** 的属性有: method 可以是 GET, HEAD, POST其中一种 url 请求的url headers 如： user-agent, referer, ... (一些特殊的 headers 不被支持在Safari and Android 浏览器里) data 一些字符串有post请求发送过去 binary 说过binary 模式，类型发送数据 timeout 超时时间 context 被添加到response对象上的对象 responseType 可以是 arraybuffer, blob, json overrideMimeType 请求的 MIME type anonymous 在请求中不需要发送cookies，详细请看fetch 注释 fetch (beta) 使用一个fetch来代替xhr请求， 在chrome中，这会导致xhr.abort、details.timeout和xhr.onprogress不工作，并使xhr.onreadystatechange仅接收readystate 4事件 username 授权的用户名 password 授权的用户密码 onabort 请求中断时执行的回调函数 onerror 请求以错误结束时需要执行的回调函数 onloadstart 请求开始加载时执行的回调函数 onprogress 请求状态变化时执行的回调函数 onreadystatechange 请求的准备状态改变是执行的回调函数 ontimeout 超时后执行的回调函数 onload 当请求被返回时执行的回调函数 ，他的几个参数如下 finalUrl - the final URL after all redirects from where the data was loaded readyState - the ready state status - the request status statusText - the request status text responseHeaders - the request response headers response - the response data as object if details.responseType was set responseXML - the response data as XML document responseText - the response data as plain string 返回的对象包含以下属性 abort - 取消请求的函数 注意: 属性synchronous 不支持 Important: 如果你想使用这个方法请移步**@connectb**标签 查看更多信息 GM_download(details), GM_download(url, name) 使用下载资源到本地磁盘 _details_的属性： url - 资源的url name - 文件名，出于安全原因，文件的扩展名必须在TM 参数页面的的白名单里 headers - 如GM_xmlhttpRequest 一样设置请求头部 saveAs - boolean 值,显示一个保存的弹窗 onerror 下载以失败结束执行的回调函数 onload 现在完成后执行的回调函数 onprogress 下载过程中变化的回调函数 ontimeout 下载超时执行的回调函数 现在文件中 onerror 的参数如下： error - 错误原因 not_enabled - 用户未启用下载功能 not_whitelisted - 下载的文件类型不在白名单里 not_permitted - 用户开启了下载权限，但没downloads权限 not_supported - 下载属性不支持，由于浏览器或者版本原因 not_succeeded - 下载没有开始或者失败了。 details可以提供更多的信息 details - 错误的详细情况 返回一个对象包含以下属性 abort - 取消下载的函数 根据下载模式，gm_u info提供一个名为download mode的属性，该属性设置为以下值之一：native、disabled或browser。 GM_getTab(callback) 获取一个持久对象，只要该选项卡处于打开状态. GM_saveTab(tab) 保存tab对象为了重新打开，在页面关闭后 GM_getTabs(callback) 获取所有tab对象作为散列与其他脚本实例通信。 GM_notification(details, ondone), GM_notification(text, title, image, onclick) 显示一个H5的桌面通知，或者高亮当前tab details 的属性： text - 通知的问题 如果高亮就 就不需要 title - 通知的标题 image - 图片 highlight - 一个boolean标志，是否高亮tab silent - 一个boolean 是否播放音乐 timeout - 通知显示的时间 0表示 一直显示 ondone - 通知被关闭时 无论是被点击还是超时 执行的函数 onclick - 点击通知触发的函数 所有参数的作用与其对应的详细信息属性挂件完全相同。 GM_setClipboard(data, info) 复制数据到粘贴板，参数info可以是对象如{type: 'text', mimetype: 'text/plain'}，或者是一个字符串 text， html GM_info 获取一些脚本和TM的信息，数据结构如下 Object+ ---&gt; script: Object+ ------&gt; author: &quot;&quot; ------&gt;copyright: &quot;2012+, You&quot; ------&gt;description: &quot;enter something useful&quot; ------&gt;excludes: Array[0] ------&gt;homepage: null ------&gt;icon: null ------&gt;icon64: null ------&gt;includes: Array[2] ------&gt;lastUpdated: 1338465932430 ------&gt;matches: Array[2] ------&gt;downloadMode: 'browser' ------&gt;name: &quot;Local File Test&quot; ------&gt;namespace: &quot;http://use.i.E.your.homepage/&quot; ------&gt;options: Object+ ---------&gt;awareOfChrome: true ---------&gt;compat_arrayleft: false ---------&gt;compat_foreach: false ---------&gt;compat_forvarin: false ---------&gt;compat_metadata: false ---------&gt;compat_prototypes: false ---------&gt;compat_uW_gmonkey: false ---------&gt;noframes: false ---------&gt;override: Object+ ------------&gt;excludes: false ------------&gt;includes: false ------------&gt;orig_excludes: Array[0] ------------&gt;orig_includes: Array[2] ------------&gt;use_excludes: Array[0] ------------&gt;use_includes: Array[0] ---------&gt;run_at: &quot;document-end&quot; ------&gt;position: 1 ------&gt;resources: Array[0] ------&gt;run-at: &quot;document-end&quot; ------&gt;system: false ------&gt;unwrap: false ------&gt;version: &quot;0.1&quot; ---&gt; scriptMetaStr: undefined ---&gt; scriptSource: &quot;// ==UserScript==\\n// @name Local File Test\\n ....&quot; ---&gt; scriptUpdateURL: undefined ---&gt; scriptWillUpdate: false ---&gt; scriptHandler: &quot;Tampermonkey&quot; ---&gt; isIncognito: false ---&gt; version: &quot;4.0.25&quot; &lt;&gt;&lt;![CDATA[your_text_here]]&gt;&lt;/&gt; tampermonkey支持这种存储元数据的方式。TM尝试自动检测脚本是否需要启用此兼容性选项。 ","link":"https://youngyuan1971.github.io/post/Tampermonkey文档解析/"},{"title":"Tampermonkey调用本地文档快速编辑脚本","content":"思路 在油猴插件中编辑脚本时，因为代码格式、代码提示等问题，不便于操作。 如果使用vscode编写脚本，完成后，复制粘贴到油猴插件中，但来来回回复制粘贴，也带来不便。 所以，在开发过程中，如果让油猴脚本调用本地js文件，代码直接在vscode中编辑，会便捷丝滑很多。 油猴插件的设置 在油猴扩展的详情中，启用允许访问文件网址 在油猴脚本编辑器中，引用本地js文件 调用执行函数 vscode中编辑代码 确保js文件路径是油猴脚本引用的路径 全部调试完成后 将vscode中的所有代码复制粘贴到油猴脚本，并删除// @require file:///Users/youngyuan/Desktop/demo.js ","link":"https://youngyuan1971.github.io/post/Tampermonkey调用本地文档快速编辑脚本/"},{"title":"Pandoc格式转换","content":"Pandoc 支持不同格式文件的转换：包括 Markdown, HTML, LaTeX，Word docx。 安装 brew install pandoc 常见格式 格式 说明 说明 pptx powerpoint 输出 docx word 输入/输出 pdf pdf 输出 html html 输入/输出 json JSON version of native AST 输入/输出 markdown Pandoc’s Markdown 输入/输出 markdown_mmd MultiMarkdown 输入/输出 markdown_phpextra (PHP Markdown Extra 输入/输出 markdown_strict original unextended Markdown 输入/输出 输入格式 'biblatex', 'bibtex', 'commonmark', 'commonmark_x', 'creole', 'csljson', 'csv', 'docbook', 'docx', 'dokuwiki', 'endnotexml', 'epub', 'fb2', 'gfm', 'haddock', 'html', 'ipynb', 'jats', 'jira', 'json', 'latex', 'man', 'markdown', 'markdown_github', 'markdown_mmd', 'markdown_phpextra', 'markdown_strict', 'mediawiki', 'muse', 'native', 'odt', 'opml', 'org', 'ris', 'rst', 'rtf', 't2t', 'textile', 'tikiwiki', 'tsv', 'twiki', 'vimwiki' 输出格式 'asciidoc', 'asciidoctor', 'beamer', 'biblatex', 'bibtex', 'commonmark', 'commonmark_x', 'context', 'csljson', 'docbook', 'docbook4', 'docbook5', 'docx', 'dokuwiki', 'dzslides', 'epub', 'epub2', 'epub3', 'fb2', 'gfm', 'haddock', 'html', 'html4', 'html5', 'icml', 'ipynb', 'jats', 'jats_archiving', 'jats_articleauthoring', 'jats_publishing', 'jira', 'json', 'latex', 'man', 'markdown', 'markdown_github', 'markdown_mmd', 'markdown_phpextra', 'markdown_strict', 'markua', 'mediawiki', 'ms', 'muse', 'native', 'odt', 'opendocument', 'opml', 'org', 'pdf', 'plain', 'pptx', 'revealjs', 'rst', 'rtf', 's5', 'slideous', 'slidy', 'tei', 'texinfo', 'textile', 'xwiki', 'zimwiki' 选项 --list-input-formats 查看输入格式 --list-output-formats 查看输出格式 -f 指定输入格式 -t 指定输出格式 -o 指定输出文件 -p, --preserve-tabs -s, --standalone** 输出选项。输出单文件 （pdf, epub, epub3, fb2, docx, odt 输出格式） –extract-media=DIR 输入选项。读取文件时，将源文件内容中的图片指定DIR目录 格式转换例子 pandoc -f markdown -t latex hello.txt pandoc -f docx -t markdown --extract-media ./images -o test.md test.docx pandoc -f docx -t markdown --extract-media ./images -o test.md e:\\\\test.docx pandoc test.txt -o test.pdf pandoc -f html -t markdown --request-header User-Agent:&quot;Mozilla/5.0&quot; https://www.fsf.org 说明： pandoc默认使用LaTeX生成PDF，需要安装LaTeX引擎。 字符编码 输入输出默认为UTF-8编码 。如果不是，则使用管道进行编码 iconv -t utf-8 input.txt | pandoc | iconv -f utf-8 Python调用Pandoc 安装pypandoc包 pip install pypandoc 调用 import pypandoc print(pypandoc.get_version()) # 2.19.1 print(pypandoc.get_pandoc_formats()[0]) # 列出支持的源文件格式 # ['biblatex', 'bibtex', 'commonmark', 'commonmark_x', 'creole', 'csljson', 'csv', 'docbook', 'docx', 'dokuwiki', 'endnotexml', 'epub', 'fb2', 'gfm', 'haddock', 'html', 'ipynb', 'jats', 'jira', 'json', 'latex', 'man', 'markdown', 'markdown_github', 'markdown_mmd', 'markdown_phpextra', 'markdown_strict', 'mediawiki', 'muse', 'native', 'odt', 'opml', 'org', 'ris', 'rst', 'rtf', 't2t', 'textile', 'tikiwiki', 'tsv', 'twiki', 'vimwiki'] print(pypandoc.get_pandoc_formats()[1]) # 列出支持的输出格式 # ['asciidoc', 'asciidoctor', 'beamer', 'biblatex', 'bibtex', 'commonmark', 'commonmark_x', 'context', 'csljson', 'docbook', 'docbook4', 'docbook5', 'docx', 'dokuwiki', 'dzslides', 'epub', 'epub2', 'epub3', 'fb2', 'gfm', 'haddock', 'html', 'html4', 'html5', 'icml', 'ipynb', 'jats', 'jats_archiving', 'jats_articleauthoring', 'jats_publishing', 'jira', 'json', 'latex', 'man', 'markdown', 'markdown_github', 'markdown_mmd', 'markdown_phpextra', 'markdown_strict', 'markua', 'mediawiki', 'ms', 'muse', 'native', 'odt', 'opendocument', 'opml', 'org', 'pdf', 'plain', 'pptx', 'revealjs', 'rst', 'rtf', 's5', 'slideous', 'slidy', 'tei', 'texinfo', 'textile', 'xwiki', 'zimwiki'] ","link":"https://youngyuan1971.github.io/post/Pandoc格式转换/"},{"title":"Macbook相关设置","content":"使用国内镜像源，安装brew /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 卸载brew /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)&quot; brew备份及批量安装 # 备份 brew bundle dump --describe --force --file=&quot;~/Desktop/Brewfile&quot; # 批量安装 brew bundle --file=&quot;~/Desktop/Brewfile&quot; 使用brew bundle --help查看帮助文档 参数说明： --describe：为列表中的命令行工具加上说明性文字。 --force：直接覆盖之前生成的Brewfile文件。如果没有该参数，则询问你是否覆盖。 --file=&quot;~/Desktop/Brewfile&quot;：在指定位置生成文件。如果没有该参数，则在当前目录生成 Brewfile 文件 卸载node和npm (官网下载的pkg安装包) sudo rm -rf /usr/local/{bin/{node,npm},lib/node_modules/npm,lib/node,share/man/*/node.*} 如果是Homebrew安裝的，则用brew uninstall node卸载 允许Mac安装任何来源的软件 sudo spctl --master-disable 软件提示无法打开、已损坏 在终端中输入以下代码 在终端输入sudo xattr -rd com.apple.quarantine后(最后有一个空格)，将应用程序中的图标拖放命令行后面 sudo xattr -rd com.apple.quarantine /Applications/&lt;软件名&gt;.app [!NOTE] 如果还有问题：需要绕过安全设置启动应用程序。在mac自带的访达中，找到该应用程序，按住control，单击鼠标左键，选择打开，该应用程序保存在安全设置的例外列表中，以后可以象任何已注册的应用程序一样通过点击启动了 修改hosts文件 sudo vim /etc/hosts Mac查看ssd健康状况 brew install smartmontools # 安装 smartctl --all /dev/disk0 突破Mac密码至少四位数的限制 pwpolicy -clearaccountpolicies 强行退出某程序 killall WeChat # 以微信为例 重置Dock defaults delete com.apple.dock; killall Dock 删除launchpad中无法正常移除的图标 访达前往文件夹/private/var/folders 在&quot;fodlers&quot;中查找com.apple.dock.launchpad 进入&quot;db&quot;文件夹，有一个&quot;db&quot;的文件，查看&quot;db&quot;路径并复制 打开终端，cd进入到复制的&quot;db&quot;文件夹路径 本机输入： cd /private/var/folders/xm/9m35f5gs11j4z15vht_cy1j40000gn/0/com.apple.dock.launchpad/db sqlite3 db &quot;delete from apps where title='应用名称';&quot;&amp;&amp;killall Dock 不能登录Microsoft网站 设置网络DNS: 4.2.2.2 设置盒盖后的睡眠状态 禁止盒盖后进入睡眠状态： sudo pmset -b sleep 0; sudo pmset -b disablesleep 1 允许盒盖后进入睡眠状态： sudo pmset -b sleep 5; sudo pmset -b disablesleep 0 刷新DNS缓存 根据不同的版本选择命令行 MACOS 版本 使用的命令 macOS 14 (sonoma) sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder macOS 13 (Ventura) sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder macOS 12 (Monterey) sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder macOS 11 (Big Sur) sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder macOS 10.15 (Catalina) sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder macOS 10.14 (Mojave) sudo killall -HUP mDNSResponder macOS 10.13 (High Sierra) sudo killall -HUP mDNSResponder macOS 10.12 (Sierra) sudo killall -HUP mDNSResponder OS X 10.11 (El Capitan) sudo killall -HUP mDNSResponder OS X 10.10 (Yosemite) sudo discoveryutil udnsflushcaches OS X 10.9 (Mavericks) sudo killall -HUP mDNSResponder OS X 10.8 (Mountain Lion) sudo killall -HUP mDNSResponder Mac OS X 10.7 (Lion) sudo killall -HUP mDNSResponder Mac OS X 10.6 (Snow Leopard) sudo dscacheutil -flushcache Mac OS X 10.5 (Leopard) sudo lookupd -flushcache Mac OS X 10.4 (Tiger) lookupd -flushcache 关闭或开启SIP SIP 全称为「System Integrity Protection」即「系统完整性保护」，是 OS X El Capitan 时开始采用的一项安全技术，SIP 将一些文件目录和系统应用保护了起来。但这会影响我们一些使用或设置，比如：更改系统应用图标、终端操作系统目录文件提示「Operation not permitted」、Finder 无法编辑系统目录里的文件。 [!WARNING] 关闭SIP有一定的风险，须谨慎使用 关闭SIP 将Mac关机状态下，长按开机键不松开，直到出现设置后松开，进入恢复模式，然后点击选项，直至看到实用工具，点击终端，输入： # 关闭SIP csrutil disable # 重启电脑 reboot 开启SIP 步骤同上，在终端输入： # 开启SIP csrutil enable # 重启电脑 reboot 压缩/解压带加密 压缩文件： # 压缩文件，无加密 zip [archive] [file] # 压缩文件，加密 zip -e [archive] [file] 压缩文件夹： # 压缩文件夹，无加密 zip -r [archive] [folder] # 压缩文件夹，加密 zip -er [archive] [folder] 解压缩： unzip filename.zip Sonoma动态屏保存储位置 下载的动态屏保体积较大，会占用存储，可以删除 cd /Library/Application\\ Support/com.apple.idleassetsd/Customer/4KSDR240FPS rm somthing.mov Sonama关闭输入法提示 输入以下命令，并重启电脑 sudo defaults write /Library/Preferences/FeatureFlags/Domain/UIKit.plist redesigned_text_cursor -dict-add Enabled -bool NO 任意位置拖动窗口 不用将鼠标移动到状态栏，使用快捷键: 同时按住ctrl+cmmand并点击鼠标左键，即可在窗口内任意位置移动窗口 在终端中输入下列代码并重启电脑： defaults write -g NSWindowShouldDragOnGesture -bool true 自带输入法长按一个按键不能连续输入 解决方法： # 全局设置 defaults write -g ApplePressAndHoldEnabled -bool false # or defaults write NSGlobalDomain ApplePressAndHoldEnabled -boolean false # or 针对某个应用单独设置 defaults write 'com.microsoft.VSCode' ApplePressAndHoldEnabled -bool false # 重启电脑 恢复方法： defaults write -g ApplePressAndHoldEnabled -bool true # 重启电脑 ","link":"https://youngyuan1971.github.io/post/Macbook相关设置/"},{"title":"Mac下使用crontab定时任务","content":"使用crontab定时任务 1、查看crontab是否启动（非必要，可跳过） sudo launchctl list | grep cron 2、命令行创建crontab执行文件&quot;testing_crontab&quot; vi testing_crontab ##输入以下代码 */1 * * * * /bin/date &gt;&gt; /Users/xx/time.txt 以上代码是每分钟执行一次date命令，输出时间到time.txt文本 3、使用crontab命令调用crontab文件 crontab testing_crontab 详解crontab定时任务 通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。 命令格式 crontab [-u user] file crontab [-u user] [ -e | -l | -r ] 命令参数 -u user：用来设定某个用户的crontab服务； file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。 -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。 -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。 -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。 -i：在删除用户的crontab文件时给确认提示。 crontab的文件格式 分 时 日 月 星期 要运行的命令 第1列分钟0～59 第2列小时0～23（0表示子夜） 第3列日1～31 第4列月1～12 第5列星期0～7（0和7表示星期天） 第6列要运行的命令 cron表达式有5位 (Linux中的crontab命令中就是5位)、6位、7位之分，不同位数之间以空格分隔 在大部分情况下会省略年这一位，成为6位，再省略秒，就成为5位 位数 每位的含义 5位：* * * * * 分、时、天、月、周 6位：* * * * * * 秒、分、时、天、月、周 7位：* * * * * * * 秒、分、时、天、月、周、年 常用方法 创建一个新的crontab文件 创建一个名为davecron的文件。在该文件中加入如下的内容。 0,15,30,45 18-06 * * * /bin/echo 'date' &gt; /dev/console 保存并退出。注意前面5个域用空格分隔。 在上面的例子中，系统将每隔15分钟向控制台输出一次当前时间。 提交你刚刚创建的crontab文件: 现在该文件已经提交给cron进程，它将每隔15分钟运行一次。同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。 列出crontab文件 使用-l参数列出crontab文件: $ crontab -l 0,15,30,45 18-06 * * * /bin/echo `date` &gt; dev/tty1 可以使用这种方法在$HOME目录中对crontab文件做一备份: $ crontab -l &gt; $HOME/mycron 编辑crontab文件 如果希望添加、删除或编辑crontab文件中的条目，而EDITOR环境变量又设置为vi，那么就可以用vi来编辑crontab文件: 可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， cron会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。 我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条： # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month 30 3 1,7,14,21,26 * * /bin/find -name 'core' -exec rm {} \\; 保存并退出。 注解：最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的定时作业。 删除crontab文件 使用实例 实例1：每1分钟执行一次myCommand * * * * * myCommand 实例2：每小时的第3和第15分钟执行 3,15 * * * * myCommand 实例3：在上午8点到11点的第3和第15分钟执行 3,15 8-11 * * * myCommand 实例4：每隔两天的上午8点到11点的第3和第15分钟执行 3,15 8-11 */2 * * myCommand 实例5：每周一上午8点到11点的第3和第15分钟执行 3,15 8-11 * * 1 myCommand 实例6：每晚的21:30重启smb 30 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb 45 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb 10 1 * * 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb 0,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb 0 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb * */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb 0 23-7 * * * /etc/init.d/smb restart 使用注意事项 注意环境变量问题 有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。 在crontab文件中定义多个调度任务时，需要特别注环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。 不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点： 脚本中涉及文件路径时写全局路径； 脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如: cat start_cbp.sh !/bin/sh source /etc/profile export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf /usr/local/jboss-4.0.5/bin/run.sh -c mev &amp; 当手动执行脚本OK，但是crontab死活不执行时,很可能是环境变量惹的祸，可尝试在crontab中直接引入环境变量解决问题。如: 0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh 注意清理系统用户的邮件日志 每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。 例如，可以在crontab文件中设置如下形式，忽略日志输出: 0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1 /dev/null 2&gt;&amp;1表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。 系统级任务调度与用户级任务调度 系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过”crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。 ","link":"https://youngyuan1971.github.io/post/Mac下使用crontab定时任务/"},{"title":"Linux常用bash命令","content":"1. Basic Operations a. export 显示所有的环境变量，如果你想获取某个变量的详细信息，使用 echo $VARIABLE_NAME. export Example: $ export SHELL=/bin/zsh AWS_HOME=/Users/adnanadnan/.aws LANG=en_US.UTF-8 LC_CTYPE=en_US.UTF-8 LESS=-R $ echo $SHELL /usr/bin/zsh b. whereis whereis使用系统自动构建的数据库来搜索可执行文件，源文件和手册页面。 whereis name Example: $ whereis php /usr/bin/php c. which 它在环境变量PATH指定的目录中搜索可执行文件。此命令将打印可执行文件的完整路径。 which program_name Example: $ which php /c/xampp/php/php d. clear 清除窗口上的内容。 1.1. File Operations a. ls 列出您的文件。ls有很多选项：-l列出“长格式”的文件，其中包含文件的确切大小，拥有该文件的人员，有权查看该文件，以及何时进行上次修改。-a列出所有文件，包括隐藏文件。有关此命令的更多信息，请检查此链接。 ls option Example: $ ls -al rwxr-xr-x 33 adnan staff 1122 Mar 27 18:44 . drwxrwxrwx 60 adnan staff 2040 Mar 21 15:06 .. -rw-r--r--@ 1 adnan staff 14340 Mar 23 15:05 .DS_Store -rw-r--r-- 1 adnan staff 157 Mar 25 18:08 .bumpversion.cfg -rw-r--r-- 1 adnan staff 6515 Mar 25 18:08 .config.ini -rw-r--r-- 1 adnan staff 5805 Mar 27 18:44 .config.override.ini drwxr-xr-x 17 adnan staff 578 Mar 27 23:36 .git -rwxr-xr-x 1 adnan staff 2702 Mar 25 18:08 .gitignore b. touch 创建或更新您的文件。 touch filename Example: $ touch trick.md c. cat 它可以在UNIX或Linux下用于以下目的。 在屏幕上显示文本文件 复制文本文件 合并文本文件 创建新的文本文件 cat filename cat file1 file2 cat file1 file2 &gt; newcombinedfile d. more 显示文件的第一部分（用空格移动并键入q以退出）。 more filename e. head 输出文件的前10行。 head filename f. tail 输出最后10行文件。用于-f在文件增长时输出附加数据。 tail filename g. mv 将文件从一个位置移动到另一个位置。 mv filename1 filename2 filename1 文件的源路径，filename2 是目标路径。 h. cp 将文件从一个位置复制到另一个位置。 cp filename1 filename2 filename1 文件的源路径，filename2 是目标路径。 i. rm 删除文件。在目录上使用此命令会给您显示一个错误： rm: directory: is a directory。 为了删除目录，你必须传递-rf去递归删除目录中的所有内容。 rm filename j. diff 比较文件，并列出他们的差异。 diff filename1 filename2 k. chmod 让您更改文件的读取，写入和执行权限。 chmod -options filename l. gzip 压缩文件。 gzip filename m. gunzip 解压缩gzip压缩的文件。 gunzip filename n. gzcat 让你查看gzip压缩文件，而不需要gunzip它。 gzcat filename o. lpr 打印文件。 lpr filename p. lpq 查看打印机队列。 lpq Example: $ lpq Rank Owner Job File(s) Total Size active adnanad 59 demo 399360 bytes 1st adnanad 60 (stdin) 0 bytes q. lprm 从打印队列移除某些内容。 lprm jobnumber 1.2. Text Operations a. awk awk是处理文本文件最有用的命令。它一行一行地在整个文件上运行。默认情况下，它使用空格分隔字段。awk命令最常用的语法是 awk '/search_pattern/ { action_to_take_if_pattern_matches; }' file_to_parse 让我们采取以下文件 /etc/passwd。以下是此文件包含的示例数据： root:x:0:0:root:/root:/usr/bin/zsh daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync 所以现在让我们从这个文件只获取用户名。 -F 指定在我们要基于哪个分隔字段。在我们的例子中 : 。{ print $1 } 意味着打印出第一个匹配字段。 awk -F':' '{ print $1 }' /etc/passwd 运行上述命令后，您将获得以下输出。 root daemon bin sys sync 有关如何使用awk的更多细节，请查看以下链接。 b. grep 查找文件内的文本。您可以使用grep搜索与一个或多个正则表达式匹配的文本行，并仅输出匹配的行。 grep pattern filename Example: $ grep admin /etc/passwd _kadmin_admin:*:218:-2:Kerberos Admin Service:/var/empty:/usr/bin/false _kadmin_changepw:*:219:-2:Kerberos Change Password Service:/var/empty:/usr/bin/false _krb_kadmin:*:231:-2:Open Directory Kerberos Admin Service:/var/empty:/usr/bin/false 您还可以通过使用-i选项强制grep忽略单词大小写。-r可用于搜索指定目录下的所有文件，例如： $ grep -r admin /etc/ -w 只搜索单词。有关grep详细信息，请查看以下链接。 c. wc 告诉你一个文件中有多少行，多少单词和多少字符。 wc filename Example: $ wc demo.txt 7459 15915 398400 demo.txt 7459 是行数, 15915 是单词数， 398400 是字符数. d. sed 用于过滤和转换文本的流编辑器。 example.txt Hello This is a Test 1 2 3 4 用连字符替换所有空格 sed 's/ /-/g' example.txt Hello-This-is-a-Test-1-2-3-4 使用&quot;d&quot;替换所有的数字 sed 's/[0-9]/d/g' example.txt Hello This is a Test d d d d e. sort 排序文本文件的行 example.txt f b c g a e d sort example.txt sort example.txt a b c d e f g 随机化一个排序的example.txt sort example.txt | sort -R b f a c d g e f. uniq 报告或省略重复的行 example.txt a a b a b c d c 只显示example.txt的唯一行（首先你需要排序，否则看不到重叠） sort example.txt | uniq a b c d 显示每行的唯一项，并告诉我找到了多少个实例 sort example.txt | uniq -c 3 a 2 b 2 c 1 d g. cut 从每行文件中删除部分。 example.txt red riding hood went to the park to play 显示第2,7和9栏的空格作为分隔符 cut -d &quot; &quot; -f2,7,9 example.txt riding park play h. echo 显示一行文字 显示 &quot;Hello World&quot; echo Hello World Hello World 用字母之间的换行显示 &quot;Hello World&quot; echo -ne &quot;Hello\\nWorld\\n&quot; Hello World i. fmt 简单的最佳文本格式化程序 example: example.txt (1 line) Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. 将example.txt的行输出为20个字符的宽度 cat example.txt | fmt -w 20 Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. j. tr 翻译或删除字符 example.txt Hello World Foo Bar Baz! 把所有小写字母变成为大写 cat example.txt | tr 'a-z' 'A-Z' HELLO WORLD FOO BAR BAZ! 把所有的空格变成换行符 cat example.txt | tr ' ' '\\n' Hello World Foo Bar Baz! k. nl 显示文件的行数 example.txt Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. 带行号显示 example.txt nl -s&quot;. &quot; example.txt 1. Lorem ipsum 2. dolor sit amet, 3. consetetur 4. sadipscing elitr, 5. sed diam nonumy 6. eirmod tempor 7. invidunt ut labore 8. et dolore magna 9. aliquyam erat, sed 10. diam voluptua. At 11. vero eos et 12. accusam et justo 13. duo dolores et ea 14. rebum. Stet clita 15. kasd gubergren, 16. no sea takimata 17. sanctus est Lorem 18. ipsum dolor sit 19. amet. l. egrep 打印匹配模式的行 - 扩展表达式（别名为：'grep -E'） example.txt Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. 在其中显示“Lorem”或“dolor”的行 egrep '(Lorem|dolor)' example.txt or grep -E '(Lorem|dolor)' example.txt Lorem ipsum dolor sit amet, et dolore magna duo dolores et ea sanctus est Lorem ipsum dolor sit m. fgrep 打印匹配模式到的行 - FIXED模式匹配（别名为：'grep -F'） example.txt Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor foo (Lorem|dolor) invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. 在example.txt中找到具体的字符串'（Lorem | doloar）' fgrep '(Lorem|dolor)' example.txt or grep -F '(Lorem|dolor)' example.txt foo (Lorem|dolor) 1.3. Directory Operations a. mkdir 生成一个新的目录。 mkdir dirname b. cd 执行这个，从一个目录转移到另外一个目录。 $ cd 将你移动到主目录。此命令接受可选的dirname，将你移动到该目录。 cd dirname c. pwd 告诉你你目前所在的目录。 pwd 1.4. SSH, System Info &amp; Network Operations a. ssh ssh (SSH client) 是一个用来在登录到远程机器并执行的命令的程序。 ssh user@host 此命令还接受-p可用于连接到特定端口的选项。 ssh -p port user@host b. whoami 返回当前登录用户名。 c. passwd 允许当前登录的用户更改其密码。 d. quota 显示您的磁盘配额。 quota -v e. date 显示当前日期和时间。 f. cal 显示月份的日历。 g. uptime 显示当前的正常运行时间。 h. w 显示谁在线 i. finger Displays information about user. finger username j. uname 显示内核信息。 uname -a k. man 显示指定命令的手册。 man command l. df 显示磁盘使用情况。 m. du 显示文件名中文件和目录的磁盘使用情况（du -s只给出一个总数）。 du filename n. last 列出您最后登录的指定用户。 last yourUsername o. ps 列出您的进程。 ps -u yourusername p. kill 使用您所提供的ID杀死（结束）进程。 kill PID q. killall 用名称杀死所有进程。 killall processname r. top 显示当前活动的进程。 s. bg 列出停止的或后台工作的Job; 恢复在后台停止的Job。 t. fg 前台化最近的Job。 Brings the most recent job in the foreground. u. ping Pings主机并输出结果。 ping host v. whois 获取域的whois信息。 whois domain w. dig 获取域的DNS信息。 dig domain x. wget 下载文件。 wget file y. scp 在本地主机和远程主机之间或两台远程主机之间传输文件。 从本地主机复制到远程主机 scp source_file user@host:directory/target_file 从远程主机复制到本地主机 scp user@host:directory/source_file target_file scp -r user@host:directory/source_folder farget_folder 此命令还接受-P选项可用于连接到特定的端口。 scp -P port user@host:directory/source_file target_file 2. Basic Shell Programming 在bash中你将编写第一行脚本文件，被叫做shebang。任何脚本中的这一行来确定脚本的执行能力，如独立的可执行文件，而不是在终端中预先键入sh，bash，python，php等。 #!/bin/bash 2.1. Variables 在bash中创建变量与其他语言类似。没有数据类型。bash中的变量可以包含数字，字符，字符串等。您无需声明变量，只需为其引用分配一个值即可创建它。 Example: str=&quot;hello world&quot; 上面的一行创建一个变量str并给它赋值“hello world”。通过$放在变量名的开头来检索变量的值。 Example: echo $str # hello world 像其他语言一样，bash也有数组。数组是包含多个值的变量。数组的大小没有最大限制。bash中的数组为零。第一个元素被索引为元素0.在bash中创建数组有几种方法。以下给出了哪些。 Examples: array[0] = val array[1] = val array[2] = val array=([2]=val [0]=val [1]=val) array(val val val) 要在特定索引处显示值，请使用以下语法： ${array[i]} # where i is the index 如果没有提供索引，则假定为数组元素0。要了解数组中有多少值，请使用以下语法： ${#array[@]} Bash也支持三元条件。下面是一些例子。 ${varname:-word} # 如果varname存在且不为null，则返回其值; 否则返回word ${varname:=word} # 如果varname存在且不为null，则返回其值;否则设置它，然后返回其值 ${varname:+word} # 如果varname存在并且不为null，返回word; 否则返回null ${varname:offset:length} # 执行子字符串扩展。它返回$ varname的子字符串，从offset开始，最多为length的字符 2.2 String Substitution 检查一些关于如何操作字符串的语法 ${variable#pattern} # if the pattern matches the beginning of the variable's value, delete the shortest part that matches and return the rest ${variable##pattern} # if the pattern matches the beginning of the variable's value, delete the longest part that matches and return the rest ${variable%pattern} # if the pattern matches the end of the variable's value, delete the shortest part that matches and return the rest ${variable%%pattern} # if the pattern matches the end of the variable's value, delete the longest part that matches and return the rest ${variable/pattern/string} # the longest match to pattern in variable is replaced by string. Only the first match is replaced ${variable//pattern/string} # the longest match to pattern in variable is replaced by string. All matches are replaced ${#varname} # returns the length of the value of the variable as a character string 2.3. Functions 几乎与任何编程语言一样，您可以使用函数以更逻辑的方式对代码段进行分组，或者实践递归的神圣艺术。声明函数只是编写函数my_func {my_code}的问题。调用一个函数就像调用另一个程序一样，你只需要写上它的名字。 functname() { shell commands } Example: #!/bin/bash function hello { echo world! } hello function say { echo $1 } say &quot;hello world!&quot; 当您运行上述示例时，该hello函数将输出“world！”。上述两个功能hello和say是相同的。主要区别是功能say。此功能打印其接收到的第一个参数。函数内的参数以与给脚本的参数相同的方式进行处理。 2.4. Conditionals bash中的条件语句与其他编程语言相似。条件有许多形式，如最基本的形式是if表达式then语句，其中语句只有在表达式为真时执行。 if [expression]; then will execute only if expression is true else will execute if expression is false fi 有时，如果条件变得混乱，所以你可以使用相同的条件case statements。 case expression in pattern1 ) statements ;; pattern2 ) statements ;; ... esac Expression Examples: statement1 &amp;&amp; statement2 # 两边的条件都为true statement1 || statement2 # 其中一边为true str1=str2 # str1 匹配 str2 str1!=str2 # str1 不匹配 str2 str1&lt;str2 # str1 是否小于 str2 str1&gt;str2 # str1 是否大于 str2 -n str1 # str1 不为空(长度大于 0) -z str1 # str1 为空(长度为 0) -a file # 文件存在 -d file # 文件存在，是一个目录 -e file # 文件存在; 相同的-a -f file # 文件存在，是一个常规文件（即不是目录或其他特殊类型的文件） -r file # 你有读权限 -r file # 文件存在，不为空 -w file # 你有写权限 -x file # 你有文件的执行权限 file1 -nt file2 # file1 is newer than file2 file1 -ot file2 # file1 is older than file2 -lt # 小于 -le # 小于或等于 -eq # 等于 -ge # 大于或等于 -gt # 大于 -ne # 不等于 2.5. Loops bash 中有三种不同类型的循环。 for, while 和 until. for 语法: for x := 1 to 10 do begin statements end for name [in list] do statements that can use $name done for (( initialisation ; ending condition ; update )) do statements... done while 语法: while condition; do statements done until 语法: until condition; do statements done 3. Tricks 设置一个别名 bash_profile 可以通过运行后面的命令打开。 nano ~/.bash_profile alias dockerlogin='ssh www-data@adnan.local -p2222' # add your alias in .bash_profile 快速去特定的目录 nano ~/.bashrc export hotellogs=&quot;/workspace/hotel-api/storage/logs&quot; source ~/.bashrc cd hotellogs 4. Debugging 您可以通过传递不同的选项来轻松地调试bash脚本bash。例如-n，不会运行命令并仅检查语法错误。-vecho命令在运行它们之前。-x命令行处理后的echo命令。 bash -n scriptname bash -v scriptname bash -x scriptname ","link":"https://youngyuan1971.github.io/post/Linux常用bash命令/"},{"title":"iterm2设置远程登录","content":" 每次使用ssh登录远程服务器，都要键入命令和密码，很不方便。所以对iterm2进行相应设置，并使用快捷键，一键登录。 编写脚本 # 进入相关目录 cd ~/.ssh # 创建脚本文件 vim ssh_server.sh 在ssh_server.sh中，编写如下代码： #!/usr/bin/expect set timeout 30 spawn ssh -p [lindex $argv 0] [lindex $argv 1]@[lindex $argv 2] expect { &quot;(yes/no)?&quot; {send &quot;yes\\n&quot;;exp_continue} &quot;password:&quot; {send &quot;[lindex $argv 3]\\n&quot;} } interact 脚本需要传入四个参数：A-端口号 B-远程服务器用户名 C-远程服务器地址 D-密码 设置iterm2 打开iterm2，在settings--profiles中，新建一个profile Name：根据自己喜好 Shotcut Key：根据自己喜好 Send text at start：~/.ssh/ssh_server.sh 22 root 192.168.3.89 ****** 如何使用 iterm2界面，快捷键ctrl+cmd+c直接登录远程服务器，或： iterm2界面，快捷键cmd+o打开profiles，选择相应服务器。 ","link":"https://youngyuan1971.github.io/post/iterm2设置远程登录/"},{"title":"Homebrew常用命令","content":"Homebrew是什么 Homebrew是MacOS不可或缺的套件管理器，开发人员必备。 安装和卸载Homebrew 安装 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 卸载 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)&quot; 更新Homebrew 要获取最新的包的列表，首先得更新Homebrew本身 brew update 安装包 brew install $FORMULA 更新包 查看需要更新的包 brew outdated 更新需要更新的包 brew upgrade # 更新所有的包 brew upgrade $FORMULA # 更新指定的包 删除包及依赖 brew uninstall $FORMULA brew autoremove # 仅删除未使用的依赖 清理旧版本 一般情况下，新版本安装了，旧版本就不需要了，可以清理。Homebrew只会清除比当前安装的包更老的版本，所以不用担心有些包没更新但被删了。 brew cleanup # 清理所有包的旧版本 brew cleanup $FORMULA # 清理指定包的旧版本 brew cleanup -n # 查看可清理的旧版本包，不执行实际操作 锁定不想更新的包 如果经常更新的话，brew update一次更新所有的包是非常方便的。但有时候会担心升级把一些不希望更新的包更新了。数据库就属于这一类。这时可以锁定这个包，忽略更新。 brew pin $FORMULA # 锁定某个包 brew unpin $FORMULA # 取消锁定 其他几个常用命令 列出所安装的包 brew list 要查看包的相关信息 brew info $FORMULA # 显示某个包的信息 brew info # 显示安装了包数量，文件数量，和总占用空间 查看包的依赖关系 brew deps --installed --tree # 查看已安装的包的依赖，树形显示 brew检测命令 brew doctor ","link":"https://youngyuan1971.github.io/post/Homebrew常用命令/"},{"title":"Git同时推送多个远程仓库","content":"准备工作 需要准备哪些环境。自然是一个本地的git仓库。 mkdir git-test cd git-test git init touch README.md 具体操作 首先思考的是如何在一个项目中添加两个远程仓库下面的命令可以给仓库添加远程仓库。 git remote add [shortname] [url] PS：我们解释一下这行命令的两个参数，第一个参数其实就是我们后面推送到这个远程仓库的时候都使用这个名称来代替仓库地址，第二个参数就是远程仓库的地址了，这句命令应该很好理解。 然后就在本地仓库根目录执行了下面两行命令，为本地仓库添加了两个远程仓库。 git remote add gitee https://gitee.com/gancy/git-test.git git remote add github https://github.com/ganchaoyang/git-test.git 另外，为了后续操作，再添加一条命令，将origin指向上述一个远程仓库。 origin是git的默认[shortname]，git push等同于git push [shortname] git remote add origin https://gitee.com/gancy/git-test.git 然后我们修改README文件后，可以分别往两个仓库推送代码。 git add * git commit -m &quot;first commit&quot; git push -u github master git push -u gitee master 通过两句git push命令我们确实可以向两个远程仓库推送代码，但是有没有一种方式可以一句命令就同时push到两个远程仓库。于是乎就有了下面的操作。直接修改了.git/config文件中的内容。原文件内容如下： [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true [remote &quot;gitee&quot;] url = https://gitee.com/gancy/git-test.git fetch = +refs/heads/*:refs/remotes/gitee/* [remote &quot;github&quot;] url = https://github.com/ganchaoyang/git-test.git fetch = +refs/heads/*:refs/remotes/github/* [branch &quot;master&quot;] remote = gitee merge = refs/heads/master 修改后的内容为： [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true [remote &quot;gitee&quot;] url = https://gitee.com/gancy/git-test.git fetch = +refs/heads/*:refs/remotes/gitee/* [remote &quot;github&quot;] url = https://github.com/ganchaoyang/git-test.git fetch = +refs/heads/*:refs/remotes/github/* [remote &quot;origin&quot;] url = https://gitee.com/gancy/git-test.git url = https://github.com/ganchaoyang/git-test.git fetch = +refs/heads/*:refs/remotes/origin/* [branch &quot;master&quot;] remote = origin merge = refs/heads/master 只是将两个remote合并成了一个而已，然后再执行git push命令就会发现，会一次性向两个仓库push代码了。 使用git remote -v查看状态，会看见pull从一个远程仓库拉取，push同时推送两个远程仓库。 结束语 这篇文章，主要是讲了如何同时向多个远程仓库推送代码。虽然平时使用场景不多，但是偶尔遇到了这样的需求还是很实用的。 ","link":"https://youngyuan1971.github.io/post/Git同时推送多个远程仓库/"},{"title":"Git指令速查表","content":"创建 复制一个已有的仓库 git clone &lt;仓库地址.git&gt; 创建一个新的本地仓库 git init 本地修改 显示工作路径下全部已修改的文件 git status 显示与上次提交版本文件的不同 git diff 把当前所有修改添加到下次提交中 git add . 指定某个文件的修改添加到下次提交中 git add -p &lt;file&gt; 提交本地的所有修改 git commit -a 提交之前已标记的变化 git commit 修改上次提交 请勿修改已发布的提交记𣲛 git commit --amend 提交历史 从最新提交开始显示所有的提交记录 git Log 显示指定文件的所有修改 git Log -p &lt;file&gt; 谁，在什么时间，修改了文件的什么内容 git blame &lt;file&gt; 分支与标签 显示所有分支 git branch -av 切换当前分支 git checkout &lt;branch&gt; 创建新分支 基于当前分支 git branch &lt;new-branch&gt; 创建新的可追潮的分支 基于远程分支 git checkout --track &lt;remote/branch&gt; 删除本地分支 git branch -d &lt;branch&gt; 给当前的提交打标签 git tag &lt;tag-name&gt; 更新与发布 列出当前配置的远程端 git remote -v 显示远程端信息 git remote show &lt;remote&gt; 添加新的远程端 git remote add &lt;shortname&gt; &lt;url&gt; 下载远程端的所有改动到本地 不会自动合并到当前 git fetch &lt;remote&gt; 下载远程端的所有改动到本地 自动合井到当前 git pull sremote&gt; cbranch&gt; 将本地版本发布到远程端 git push &lt;remote&gt; &lt;branch&gt; 删除远程端分支 git branch -dr &lt;remote/branch&gt; 发布标签 git push --tags 合并与重置 将分支合并到当前 git merge &lt;branch&gt; 将当前版本重置到分支中 请勿重置已发布的提交 git rebase &lt;branch&gt; 退出重置 git rebase --abort 解决冲突后继续重置 git rebase --continue 使用配置好的合井工具去解决冲突 git mergetool 在编辑器中手动解决冲突后 标记文件为已解决冲突 git add &lt;resolved-file&gt; git rm &lt;resolved-file&gt; 撤销 放弃工作目录下的所有修改 git reset --hard HEAD 放弃某个文件的所有本地修改 git checkout HEAD &lt;file&gt; 重置一个提交 通过创建一个截然不同的新提交 git revert &lt;commit&gt; 将HEAD重置到上一次提交的版本 并抛弃该版本之后的所有修改 git reset --hard &lt;commit&gt; 并将之后修改标记为未添加到缓存区的修改 git reset &lt;commit&gt; 并保留未提交的本地修改 git reset --keep &lt;commit&gt; 附件：Git指令速查图 ","link":"https://youngyuan1971.github.io/post/Git指令速查表/"},{"title":"FFmpeg基本命令","content":" Excerpt 在这个指南中，我将用示例来阐明如何使用 FFmpeg 媒体框架来做各种各样的音频、视频转码和转换的操作。 -- Sk（作者）在这个指南中，我将用示例来阐明如何使用 FFmpeg 媒体框架来做各种各样的音频、视频转码和转换… 在这个指南中，我将用示例来阐明如何使用 FFmpeg 媒体框架来做各种各样的音频、视频转码和转换的操作。我已经为初学者汇集了最常用的 20 多个 FFmpeg 命令，我将不时地添加更多的示例来保持更新这个指南。请给这个指南加书签，以后回来检查更新。让我们开始吧，如果你还没有在你的 Linux 系统中安装 FFmpeg，参考下面的指南。 在 Linux 中安装 FFmpeg FFmpeg 命令的典型语法是： ffmpeg [全局选项] {[输入文件选项] -i 输入_url_地址} ... {[输出文件选项] 输出_url_地址} ... 现在我们将查看一些重要的和有用的 FFmpeg 命令。 1、获取音频/视频文件信息 为显示你的媒体文件细节，运行： 样本输出： ffmpeg version n4.1.3 Copyright (c) 2000-2019 the FFmpeg developers built with gcc 8.2.1 (GCC) 20181127 configuration: --prefix=/usr --disable-debug --disable-static --disable-stripping --enable-fontconfig --enable-gmp --enable-gnutls --enable-gpl --enable-ladspa --enable-libaom --enable-libass --enable-libbluray --enable-libdrm --enable-libfreetype --enable-libfribidi --enable-libgsm --enable-libiec61883 --enable-libjack --enable-libmodplug --enable-libmp3lame --enable-libopencore_amrnb --enable-libopencore_amrwb --enable-libopenjpeg --enable-libopus --enable-libpulse --enable-libsoxr --enable-libspeex --enable-libssh --enable-libtheora --enable-libv4l2 --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxcb --enable-libxml2 --enable-libxvid --enable-nvdec --enable-nvenc --enable-omx --enable-shared --enable-version3 libavutil 56. 22.100 / 56. 22.100 libavcodec 58. 35.100 / 58. 35.100 libavformat 58. 20.100 / 58. 20.100 libavdevice 58. 5.100 / 58. 5.100 libavfilter 7. 40.101 / 7. 40.101 libswscale 5. 3.100 / 5. 3.100 libswresample 3. 3.100 / 3. 3.100 libpostproc 55. 3.100 / 55. 3.100 Input #0, mov,mp4,m4a,3gp,3g2,mj2, from 'video.mp4': Metadata: major_brand : isom minor_version : 512 compatible_brands: isomiso2avc1mp41 encoder : Lavf58.20.100 Duration: 00:00:28.79, start: 0.000000, bitrate: 454 kb/s Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, smpte170m/bt470bg/smpte170m), 1920x1080 [SAR 1:1 DAR 16:9], 318 kb/s, 30 fps, 30 tbr, 15360 tbn, 60 tbc (default) Metadata: handler_name : ISO Media file produced by Google Inc. Created on: 04/08/2019. Stream #0:1(eng): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default) Metadata: handler_name : ISO Media file produced by Google Inc. Created on: 04/08/2019. At least one output file must be specified 如你在上面的输出中看到的，FFmpeg 显示该媒体文件信息，以及 FFmpeg 细节，例如版本、配置细节、版权标记、构建参数和库选项等等。 如果你不想看 FFmpeg 标语和其它细节，而仅仅想看媒体文件信息，使用 -hide_banner 标志，像下面。 $ ffmpeg -i video.mp4 -hide_banner 样本输出： 使用 FFMpeg 查看音频、视频文件信息。 看见了吗？现在，它仅显示媒体文件细节。 2、转换视频文件到不同的格式 FFmpeg 是强有力的音频和视频转换器，因此，它能在不同格式之间转换媒体文件。举个例子，要转换 mp4 文件到 avi 文件，运行： $ ffmpeg -i video.mp4 video.avi 类似地，你可以转换媒体文件到你选择的任何格式。 例如，为转换 YouTube flv 格式视频为 mpeg 格式，运行： $ ffmpeg -i video.flv video.mpeg 如果你想维持你的源视频文件的质量，使用 -qscale 0 参数： $ ffmpeg -i input.webm -qscale 0 output.mp4 3、转换视频文件到音频文件 我转换一个视频文件到音频文件，只需具体指明输出格式，像 .mp3，或 .ogg，或其它任意音频格式。 上面的命令将转换 input.mp4 视频文件到 output.mp3 音频文件。 $ ffmpeg -i input.mp4 -vn output.mp3 此外，你也可以对输出文件使用各种各样的音频转换编码选项，像下面演示。 $ ffmpeg -i input.mp4 -vn -ar 44100 -ac 2 -ab 320 -f mp3 output.mp3 在这里， -vn – 表明我们已经在输出文件中禁用视频录制。 -ar – 设置输出文件的音频频率。通常使用的值是22050 Hz、44100 Hz、48000 Hz。 -ac – 设置音频通道的数目。 -ab – 表明音频比特率。 -f – 输出文件格式。在我们的实例中，它是 mp3 格式。 4、更改视频文件的分辨率 如果你想设置一个视频文件为指定的分辨率，你可以使用下面的命令： $ ffmpeg -i input.mp4 -filter:v scale=1280:720 -c:a copy output.mp4 或， $ ffmpeg -i input.mp4 -s 1280x720 -c:a copy output.mp4 上面的命令将设置所给定视频文件的分辨率到 1280×720。 类似地，为转换上面的文件到 640×480 大小，运行： $ ffmpeg -i input.mp4 -filter:v scale=640:480 -c:a copy output.mp4 或者， $ ffmpeg -i input.mp4 -s 640x480 -c:a copy output.mp4 这个技巧将帮助你缩放你的视频文件到较小的显示设备上，例如平板电脑和手机。 5、压缩视频文件 减小媒体文件的大小到较小来节省硬件的空间总是一个好主意. 下面的命令将压缩并减少输出文件的大小。 $ ffmpeg -i input.mp4 -vf scale=1280:-1 -c:v libx264 -preset veryslow -crf 24 output.mp4 请注意，如果你尝试减小视频文件的大小，你将损失视频质量。如果 24 太有侵略性，你可以降低 -crf 值到或更低值。 你也可以通过下面的选项来转换编码音频降低比特率，使其有立体声感，从而减小大小。 -ac 2 -c:a aac -strict -2 -b:a 128k 6、压缩音频文件 正像压缩视频文件一样，为节省一些磁盘空间，你也可以使用 -ab 标志压缩音频文件。 例如，你有一个 320 kbps 比特率的音频文件。你想通过更改比特率到任意较低的值来压缩它，像下面。 $ ffmpeg -i input.mp3 -ab 128 output.mp3 各种各样可用的音频比特率列表是： 96kbps 112kbps 128kbps 160kbps 192kbps 256kbps 320kbps 7、从一个视频文件移除音频流 如果你不想要一个视频文件中的音频，使用 -an 标志。 $ ffmpeg -i input.mp4 -an output.mp4 在这里，-an 表示没有音频录制。 上面的命令会撤销所有音频相关的标志，因为我们不要来自 input.mp4 的音频。 8、从一个媒体文件移除视频流 类似地，如果你不想要视频流，你可以使用 -vn 标志从媒体文件中简单地移除它。-vn 代表没有视频录制。换句话说，这个命令转换所给定媒体文件为音频文件。 下面的命令将从所给定媒体文件中移除视频。 $ ffmpeg -i input.mp4 -vn output.mp3 你也可以使用 -ab 标志来指出输出文件的比特率，如下面的示例所示。 $ ffmpeg -i input.mp4 -vn -ab 320 output.mp3 9、从视频中提取图像 FFmpeg 的另一个有用的特色是我们可以从一个视频文件中轻松地提取图像。如果你想从一个视频文件中创建一个相册，这可能是非常有用的。 为从一个视频文件中提取图像，使用下面的命令： $ ffmpeg -i input.mp4 -r 1 -f image2 image-%2d.png 在这里， -r – 设置帧速度。即，每秒提取帧到图像的数字。默认值是 25。 -f – 表示输出格式，即，在我们的实例中是图像。 image-%2d.png – 表明我们如何想命名提取的图像。在这个实例中，命名应该像这样image-01.png、image-02.png、image-03.png 等等开始。如果你使用 %3d，那么图像的命名像 image-001.png、image-002.png 等等开始。 10、裁剪视频 FFMpeg 允许以我们选择的任何范围裁剪一个给定的媒体文件。 裁剪一个视频文件的语法如下给定： ffmpeg -i input.mp4 -filter:v &quot;crop=w:h:x:y&quot; output.mp4 在这里， input.mp4 – 源视频文件。 -filter:v – 表示视频过滤器。 crop – 表示裁剪过滤器。 w – 我们想自源视频中裁剪的矩形的宽度。 h – 矩形的高度。 x – 我们想自源视频中裁剪的矩形的 x 坐标 。 y – 矩形的 y 坐标。 比如说你想要一个来自视频的位置 (200,150)，且具有 640 像素宽度和 480 像素高度的视频，命令应该是： $ ffmpeg -i input.mp4 -filter:v &quot;crop=640:480:200:150&quot; output.mp4 请注意，剪切视频将影响质量。除非必要，请勿剪切。 11、转换一个视频的具体的部分 有时，你可能想仅转换视频文件的一个具体的部分到不同的格式。以示例说明，下面的命令将转换所给定视频input.mp4 文件的开始 10 秒到视频 .avi 格式。 $ ffmpeg -i input.mp4 -t 10 output.avi 在这里，我们以秒具体说明时间。此外，以 hh.mm.ss 格式具体说明时间也是可以的。 12、设置视频的屏幕高宽比 你可以使用 -aspect 标志设置一个视频文件的屏幕高宽比，像下面。 $ ffmpeg -i input.mp4 -aspect 16:9 output.mp4 通常使用的高宽比是： 16:9 4:3 16:10 5:4 2:21:1 2:35:1 2:39:1 13、添加海报图像到音频文件 你可以添加海报图像到你的文件，以便图像将在播放音频文件时显示。这对托管在视频托管主机或共享网站中的音频文件是有用的。 $ ffmpeg -loop 1 -i inputimage.jpg -i inputaudio.mp3 -c:v libx264 -c:a aac -strict experimental -b:a 192k -shortest output.mp4 14、使用开始和停止时间剪下一段媒体文件 可以使用开始和停止时间来剪下一段视频为小段剪辑，我们可以使用下面的命令。 $ ffmpeg -i input.mp4 -ss 00:00:50 -codec copy -t 50 output.mp4 在这里， –s – 表示视频剪辑的开始时间。在我们的示例中，开始时间是第 50 秒。 -t – 表示总的持续时间。 当你想使用开始和结束时间从一个音频或视频文件剪切一部分时，它是非常有用的。 类似地，我们可以像下面剪下音频。 $ ffmpeg -i audio.mp3 -ss 00:01:54 -to 00:06:53 -c copy output.mp3 15、切分视频文件为多个部分 一些网站将仅允许你上传具体指定大小的视频。在这样的情况下，你可以切分大的视频文件到多个较小的部分，像下面。 $ ffmpeg -i input.mp4 -t 00:00:30 -c copy part1.mp4 -ss 00:00:30 -codec copy part2.mp4 在这里， -t 00:00:30 表示从视频的开始到视频的第 30 秒创建一部分视频。 -ss 00:00:30 为视频的下一部分显示开始时间戳。它意味着第 2 部分将从第 30 秒开始，并将持续到原始视频文件的结尾。 16、接合或合并多个视频部分到一个 FFmpeg 也可以接合多个视频部分，并创建一个单个视频文件。 方法一 创建包含你想接合文件的准确的路径的 join.txt。所有的文件都应该是相同的格式（相同的编码格式）。所有文件的路径应该逐个列出，像下面。 file /where/your/path/part1.mp4 file /where/your/path/part2.mp4 file /where/your/path/part3.mp4 file /where/your/path/part4.mp4 现在，接合所有文件，使用命令： $ ffmpeg -f concat -i join.txt -c copy output.mp4 如果你得到一些像下面的错误； [concat @ 0x555fed174cc0] Unsafe file name '/path/to/mp4' join.txt: Operation not permitted 添加 -safe 0 : $ ffmpeg -f concat -safe 0 -i join.txt -c copy output.mp4 上面的命令将接合 part1.mp4、part2.mp4、part3.mp4 和 part4.mp4 文件到一个称为 output.mp4 的单个文件中。 方法二 ffmpeg -i &quot;concat:input1.mp4|input2.mp4|input3.mp4&quot; -c copy output.mp4 上述命令适合少量的视频文件合并 17、添加字幕到一个视频文件 我们可以使用 FFmpeg 来添加字幕到视频文件。为你的视频下载正确的字幕，并如下所示添加它到你的视频。 $ fmpeg -i input.mp4 -i subtitle.srt -map 0 -map 1 -c copy -c:v libx264 -crf 23 -preset veryfast output.mp4 18、预览或测试视频或音频文件 你可能希望通过预览来验证或测试输出的文件是否已经被恰当地转码编码。为完成预览，你可以从你的终端播放它，用命令： 类似地，你可以测试音频文件，像下面所示。 19、增加/减少视频播放速度 FFmpeg 允许你调整视频播放速度。 为增加视频播放速度，运行： $ ffmpeg -i input.mp4 -vf &quot;setpts=0.5*PTS&quot; output.mp4 该命令将双倍视频的速度。 为降低你的视频速度，你需要使用一个大于 1 的倍数。为减少播放速度，运行： $ ffmpeg -i input.mp4 -vf &quot;setpts=4.0*PTS&quot; output.mp4b 20、创建动画的 GIF 出于各种目的，我们在几乎所有的社交和专业网络上使用 GIF 图像。使用 FFmpeg，我们可以简单地和快速地创建动画的视频文件。下面的指南阐释了如何在类 Unix 系统中使用 FFmpeg 和 ImageMagick 创建一个动画的 GIF 文件。 在 Linux 中如何创建动画的 GIF 21、从 PDF 文件中创建视频 我长年累月的收集了很多 PDF 文件，大多数是 Linux 教程，保存在我的平板电脑中。有时我懒得从平板电脑中阅读它们。因此，我决定从 PDF 文件中创建一个视频，在一个大屏幕设备（像一台电视机或一台电脑）中观看它们。如果你想知道如何从一批 PDF 文件中制作一个电影，下面的指南将帮助你。 在 Linux 中如何从 PDF 文件中创建一个视频 ","link":"https://youngyuan1971.github.io/post/FFmpeg基本命令/"},{"title":"ASCII 对照表","content":" ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 &quot; 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 \\ 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL 特殊字符解释 NUL空 VT 垂直制表 SYN 空转同步 STX 正文开始 CR 回车 CAN 作废 ETX 正文结束 SO 移位输出 EM 纸尽 EOY 传输结束 SI 移位输入 SUB 换置 ENQ 询问字符 DLE 空格 ESC 换码 ACK 承认 DC1 设备控制1 FS 文字分隔符 BEL 报警 DC2 设备控制2 GS 组分隔符 BS 退一格 DC3 设备控制3 RS 记录分隔符 HT 横向列表 DC4 设备控制4 US 单元分隔符 LF 换行 NAK 否定 DEL 删除 ","link":"https://youngyuan1971.github.io/post/ASCII 对照表/"},{"title":"aria2使用和配置","content":"aria2（命令行下载）使用 aria2 是一个自由、开源、轻量级多协议和多源的命令行下载工具。它支持 HTTP/HTTPS、FTP、SFTP、 BitTorrent 和 Metalink 协议。aria2 可以通过内建的 JSON-RPC 和 XML-RPC 接口来操纵。aria2 下载文件的时候，自动验证数据块。它可以通过多个来源或者多个协议下载一个文件，并且会尝试利用你的最大下载带宽。默认情况下，所有的 Linux 发行版都包括 aria2，所以我们可以从官方库中很容易的安装。一些 GUI 下载管理器例如 uget 使用 aria2 作为插件来提高下载速度。 aria2特性： 支持 HTTP/HTTPS GET 支持 HTTP 代理 支持 HTTP BASIC 认证 支持 HTTP 代理认证 支持 FTP （主动、被动模式） 通过 HTTP 代理的 FTP（GET 命令行或者隧道） 分段下载 支持 Cookie 可以作为守护进程运行。 支持使用 fast 扩展的 BitTorrent 协议 支持在多文件 torrent 中选择文件 支持 Metalink 3.0 版本（HTTP/FTP/BitTorrent） 限制下载、上传速度 1、安装 我们可以很容易的在所有的 Linux 发行版上安装 aria2 命令行下载器，例如 Debian、 Ubuntu、 Mint、 RHEL、 CentOS、 Fedora、 suse、 openSUSE、 Arch Linux、 Manjaro、 Mageia 等等……只需要输入下面的命令安装即可。对于 CentOS、 RHEL 系统，我们需要开启 uget 或者 RPMForge 库的支持。 [对于MacOS] $ brew install aria2 [对于 Debian、 Ubuntu 和 Mint] $ sudo apt-get install aria2 [对于 CentOS、 RHEL、 Fedora 21 和更早些的操作系统] # yum install aria2 2、简单使用 2.1 下载单个文件 下面的命令将会从指定的 URL 中下载一个文件，并且保存在当前目录，在下载文件的过程中，我们可以看到文件的（日期、时间、下载速度和下载进度）。 aria2c https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2 [#986c80 19MiB/21MiB(90%) CN:1 DL:3.0MiB] 03/22 09:49:13 [NOTICE] Download complete: /opt/owncloud-9.0.0.tar.bz2 Download Results: gid |stat|avg speed |path/URI ======+====+===========+======================================================= 986c80|OK | 3.0MiB/s|/opt/owncloud-9.0.0.tar.bz2 Status Legend: (OK):download completed. 2.2 使用不同的名字保存文件 在初始化下载的时候，我们可以使用-o（小写）选项在保存文件的时候使用不同的名字。这儿我们将要使用 owncloud.zip 文件名来保存文件。 aria2c -o owncloud.zip https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2 [#d31304 16MiB/21MiB(74%) CN:1 DL:6.2MiB] 03/22 09:51:02 [NOTICE] Download complete: /opt/owncloud.zip Download Results: gid |stat|avg speed |path/URI ======+====+===========+======================================================= d31304|OK | 7.3MiB/s|/opt/owncloud.zip Status Legend: (OK):download completed. 2.3 下载速度限制 默认情况下，aria2 会利用全部带宽来下载文件，在文件下载完成之前，我们在服务器就什么也做不了（这将会影响其他服务访问带宽）。所以在下载大文件时最好使用 --max-download-limit 选项来避免进一步的问题。 aria2c --max-download-limit=500k https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2 [#7f9fbf 21MiB/21MiB(99%) CN:1 DL:466KiB] 03/22 09:54:51 [NOTICE] Download complete: /opt/owncloud-9.0.0.tar.bz2 Download Results: gid |stat|avg speed |path/URI ======+====+===========+======================================================= 7f9fbf|OK | 462KiB/s|/opt/owncloud-9.0.0.tar.bz2 Status Legend: (OK):download completed. 2.4 下载多个文件 下面的命令将会从指定位置下载超过一个的文件并保存到当前目录，在下载文件的过程中，我们可以看到文件的（日期、时间、下载速度和下载进度）。 aria2c -Z https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2 ftp://ftp.gnu.org/gnu/wget/wget-1.17.tar.gz [DL:1.7MiB][#53533c 272KiB/21MiB(1%)][#b52bb1 768KiB/3.6MiB(20%)] 03/22 10:25:54 [NOTICE] Download complete: /opt/wget-1.17.tar.gz [#53533c 18MiB/21MiB(86%) CN:1 DL:3.2MiB] 03/22 10:25:59 [NOTICE] Download complete: /opt/owncloud-9.0.0.tar.bz2 Download Results: gid |stat|avg speed |path/URI ======+====+===========+======================================================= b52bb1|OK | 2.8MiB/s|/opt/wget-1.17.tar.gz 53533c|OK | 3.4MiB/s|/opt/owncloud-9.0.0.tar.bz2 Status Legend: (OK):download completed. 使用 -P 参数来扩展下载地址： aria2c -Z -P &quot;http://host/image{1,2,3}_{A,B,C}.png&quot; 5da2af|ERR | 0B/s|http://host/image1_A.png%0A 3c98a4|ERR | 0B/s|http://host/image1_B.png%0A 17ba0a|ERR | 0B/s|http://host/image1_C.png%0A e7afa3|ERR | 0B/s|http://host/image2_A.png%0A e99fcf|ERR | 0B/s|http://host/image2_B.png%0A 1f151a|ERR | 0B/s|http://host/image2_C.png%0A 2da0f1|ERR | 0B/s|http://host/image3_A.png%0A 17b599|ERR | 0B/s|http://host/image3_B.png%0A d9f5ad|ERR | 0B/s|http://host/image3_C.png%0A 2.5 续传未完成的下载 当你遇到一些网络连接问题或者系统问题的时候，并将要下载一个大文件（例如： ISO 镜像文件），我建议你使用 -c 选项，它可以帮助我们从该状态续传未完成的下载，并且像往常一样完成。不然的话，当你再次下载，它将会初始化新的下载，并保存成一个不同的文件名（自动的在文件名后面添加 .1 ）。注意：如果出现了任何中断，aria2 使用 .aria2 后缀保存（未完成的）文件。 aria2c -c https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2 [#db0b08 8.2MiB/21MiB(38%) CN:1 DL:3.1MiB ETA:4s]^C 03/22 10:09:26 [NOTICE] Shutdown sequence commencing... Press Ctrl-C again for emergency shutdown. 03/22 10:09:26 [NOTICE] Download GID#db0b08bf55d5908d not complete: /opt/owncloud-9.0.0.tar.bz2 Download Results: gid |stat|avg speed |path/URI ======+====+===========+======================================================= db0b08|INPR| 3.3MiB/s|/opt/owncloud-9.0.0.tar.bz2 Status Legend: (INPR):download in-progress. 如果重新启动传输，aria2 将会恢复下载。 # aria2c -c https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2 [#873d08 21MiB/21MiB(98%) CN:1 DL:2.7MiB] 03/22 10:09:57 [NOTICE] Download complete: /opt/owncloud-9.0.0.tar.bz2 Download Results: gid |stat|avg speed |path/URI ======+====+===========+======================================================= 873d08|OK | 1.9MiB/s|/opt/owncloud-9.0.0.tar.bz2 Status Legend: (OK):download completed. 2.6 从文件获取输入 就像 wget 可以从一个文件获取输入的 URL 列表来下载一样。我们需要创建一个文件，将每一个 URL 存储在单独的行中。aria2 命令行可以添加 -i 选项来执行此操作。 aria2c -i test-aria2.txt [DL:3.9MiB][#b97984 192KiB/21MiB(0%)][#673c8e 2.5MiB/3.6MiB(69%)] 03/22 10:14:22 [NOTICE] Download complete: /opt/wget-1.17.tar.gz [#b97984 19MiB/21MiB(90%) CN:1 DL:2.5MiB] 03/22 10:14:30 [NOTICE] Download complete: /opt/owncloud-9.0.0.tar.bz2 Download Results: gid |stat|avg speed |path/URI ======+====+===========+======================================================= 673c8e|OK | 4.3MiB/s|/opt/wget-1.17.tar.gz b97984|OK | 2.5MiB/s|/opt/owncloud-9.0.0.tar.bz2 Status Legend: (OK):download completed. 2.7 每个主机使用两个连接来下载 默认情况，每次下载连接到一台服务器的最大数目，对于一条主机只能建立一条。我们可以通过 aria2 命令行添加 -x2（2 表示两个连接）来创建到每台主机的多个连接，以加快下载速度。 aria2c -x2 https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2 [#ddd4cd 18MiB/21MiB(83%) CN:1 DL:5.0MiB] 03/22 10:16:27 [NOTICE] Download complete: /opt/owncloud-9.0.0.tar.bz2 Download Results: gid |stat|avg speed |path/URI ======+====+===========+======================================================= ddd4cd|OK | 5.5MiB/s|/opt/owncloud-9.0.0.tar.bz2 Status Legend: (OK):download completed. 2.8 下载 BitTorrent 种子文件 我们可以使用 aria2 命令行直接下载一个 BitTorrent 种子文件： aria2c https://torcache.net/torrent/C86F4E743253E0EBF3090CCFFCC9B56FA38451A3.torrent?title=[kat.cr]irudhi.suttru.2015.official.teaser.full.hd.1080p.pathi.team.sr [#388321 0B/0B CN:1 DL:0B] 03/22 20:06:14 [NOTICE] Download complete: /opt/[kat.cr]irudhi.suttru.2015.official.teaser.full.hd.1080p.pathi.team.sr.torrent 03/22 20:06:14 [ERROR] Exception caught Exception: [BtPostDownloadHandler.cc:98] errorCode=25 Could not parse BitTorrent metainfo Download Results: gid |stat|avg speed |path/URI ======+====+===========+======================================================= 388321|OK | 11MiB/s|/opt/[kat.cr]irudhi.suttru.2015.official.teaser.full.hd.1080p.pathi.team.sr.torrent Status Legend: (OK):download completed. 2.9 下载 BitTorrent 磁力链接 使用 aria2 我们也可以通过 BitTorrent 磁力链接直接下载一个种子文件： aria2c 'magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C' 2.10 下载 BitTorrent Metalink 种子 我们也可以通过 aria2 命令行直接下载一个 Metalink 文件。 aria2c https://curl.haxx.se/metalink.cgi?curl=tar.bz2 2.11 从密码保护的网站下载一个文件 或者，我们也可以从一个密码保护网站下载一个文件。下面的命令行将会从一个密码保护网站中下载文件。 aria2c --http-user=xxx --http-password=xxx https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2 aria2c --ftp-user=xxx --ftp-password=xxx ftp://ftp.gnu.org/gnu/wget/wget-1.17.tar.gz 2.12 更多命令 使用man aria2c或aria2c -h查看更多详细参数信息。 aria2（RPC接口）使用 配置RPC接口后，aria2不能直接用命令行下载而是开启了RPC服务 如要用命令行下载，需在命令行中加入参数--no-conf，意思是不使用配置文件 aria2c --no-conf [url] [相关参数] 1、配置 $ cd ~/.config $ mkdir aria2 $ cd aria2 $ touch aria2.conf aria2.session aria2.log 1.1 设置aria2.conf如下： #用户名 #rpc-user=user #密码 #rpc-passwd=passwd #上面的认证方式不建议使用,建议使用下面的token方式 #设置加密的密钥 #rpc-secret=token #允许rpc enable-rpc=true #允许所有来源, web界面跨域权限需要 rpc-allow-origin-all=true #允许外部访问，false的话只监听本地端口 rpc-listen-all=true #RPC端口, 仅当默认端口被占用时修改 #rpc-listen-port=6800 #最大同时下载数(任务数), 路由建议值: 3 max-concurrent-downloads=5 #断点续传 continue=true #同服务器连接数 max-connection-per-server=5 #最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要 min-split-size=10M #单文件最大线程数, 路由建议值: 5 split=10 #下载速度限制 max-overall-download-limit=0 #单文件速度限制 max-download-limit=0 #上传速度限制 max-overall-upload-limit=0 #单文件速度限制 max-upload-limit=0 #断开速度过慢的连接 #lowest-speed-limit=0 #验证用，需要1.16.1之后的release版本 #referer=* #文件保存路径, 默认为当前启动位置 dir=/Users/xxx/Downloads #文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本 #disk-cache=0 #另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?) #enable-mmap=true #文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长 #所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持 file-allocation=prealloc 配置示例下载 默认下载路径的「/Users/xxx/Downloads」可以改为任何你想要的绝对路径。此处写为 Downloads 目录，xxx 请自行替换成你的 Mac 用户名，然后保存，退出编辑器。 1.2 启动服务 $ aria2c 启动服务后，aria2会自动查找配置文件 1.3 终止服务 control+C或： 终端输入kill aria2c后按table键显示进程id，按Enter完成 2、配置web界面 2.1 本地文件配置 $ git clone https://github.com/ziahamza/webui-aria2 $ cd webui-aria2 $ open index.html 然后在浏览器中添加收藏 2.2 浏览器配置(推荐) 安装chrome浏览器插件Aria2 for Chrome 参考: aria2 （命令行下载器）实例 aria2 配置详解 aria2官方文档 [aria2 使用说明]( ","link":"https://youngyuan1971.github.io/post/aria2使用和配置/"},{"title":"虚拟机安装Centos Linux及Docker(Mac)","content":"一、安装CenOS Linux 环境 Mac-m1 虚拟机Parallels Desktop18，安装略过。 下载CentOS Linux镜像，并使用PD虚拟机创建CentOS Linux系统。 安装 第一次输入 r 依次输入 5,c,c,c,8 然后设置密码，确认密码（这里密码需要设置的稍微复杂些） 之后输入b 接下来等着安装，这一步比较慢，耐心等待 安装完成 安装完成后出现刚才这个界面 输入1 - 回车 - 输入2 - 回车 输入c - 回车 - 输入c - 回车 即可解决 接下来输入用户名和密码即可登录 配置网络 # 安装网络工具，以后可以使用ifconfig查看网络状态 yum install -y net-tools # 设置静态地址及相关，虚拟机采用桥接WIFI，使用宿主机的MAC地址 cd /etc/sysconfig/network-scripts/ vi ifcfg-enp0s5 # 修改以下内容 BOOTPROTO=static ONBOOT=yes # 增加以下内容 HWADDR=00:1C:42:AF:64:A9 IPADDR=192.168.3.89 GATEWAY=192.168.3.1 NETMASK=255.255.255.0 DNS1=192.168.3.1 DNS2=8.8.8.8 非常重要：HWADDR是MAC地址，必须要填写，否则静态地址不起作用 修改后重启 修改后保存并退出，键入： # 重启网卡 nmcli c reload # 重启系统 reboot ping www.baidu.com 即可看到连接上网络 其他 如果重启网卡可以使用systemctl restart NetworkManager 但是，输入这个systemctl restart network 或 service network restart重启网卡报错 这里简单说下我的解决办法： centos8 不能重启网络报错原因 Failed to restart network.service: Unit network.service not found 由于 centos8 已经替换了原来的network, 新版的叫：NetworkManager 所以用这个命令就可以重启了 systemctl restart NetworkManager 重启后查询运行状态：systemctl status NetworkManager 关闭访火墙 查看防火墙状态：systemctl status firewalld.service 关闭：systemctl stop firewalld.service 永久关闭： systemctl disable firewalld.service 远程访问 ssh root@192.168.3.89 配置代理 vi /etc/profile # 添加以下内容 export http_proxy=&quot;http://192.168.3.88:7890&quot; export https_proxy=&quot;http://192.168.3.88:7890&quot; 二、安装Docker 设置存储库 根据Docker官方文档,按照步骤： 安装yum-utils包（提供yum-config-manager 实用程序）并设置存储库。 yum update yum install -y yum-utils yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装 Docker 引擎 yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin # 启动Docker systemctl start docker # 开机启动Docker systemctl enable docker 通过运行映像验证 Docker 引擎安装是否成功 hello-world docker run hello-world 安装 Docker-Compose 在github仓库中下载到本地，或通过命令行： curl -L &quot;https://github.com/docker/compose/releases/download/v2.18.1/docker-compose-linux-aarch64&quot; -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose # 查看docker-compose版本 docker-compose --version 配置Docker镜像加速 在/etc/docker下，新建daemon.json文件，并编辑: { &quot;registry-mirrors&quot;: [ &quot;https://dockerproxy.com&quot;, &quot;https://2au2qwfj.mirror.aliyuncs.com&quot;, &quot;http://hub-mirror.c.163.com&quot; ] } 然后重启Docker，并查看信息： systemctl restart docker docker info 三、添加新用户并授权 创建新用户 创建一个用户名为：youngyuan 为这个用户初始化密码，linux会判断密码复杂度，不过可以强行忽略： # 添加用户 adduser youngyuan # 设置密码 passwd youngyuan 授权 个人用户的权限只可以在本home下有完整权限，其他目录要看别人授权。而经常需要root用户的权限，这时候sudo可以化身为root来操作。如果用sudo创建了文件，然后发现并没有读写权限，因为查看权限是root创建的。 新创建的用户并不能使用sudo命令，需要给他添加授权。 sudo命令的授权管理是在sudoers文件里的。可以看看sudoers： sudoers # bash: sudoers: 未找到命令... whereis sudoers # sudoers: /etc/sudoers /etc/sudoers.d /usr/libexec/sudoers.so /usr/share/man/man5/sudoers.5.gz 找到这个文件位置之后再查看权限： ls -l /etc/sudoers # -r--r----- 1 root root 4251 9月 25 15:08 /etc/sudoers 是的，只有只读的权限，如果想要修改的话，需要先添加w权限： chmod -v u+w /etc/sudoers # mode of &quot;/etc/sudoers&quot; changed from 0440 (r--r-----) to 0640 (rw-r-----) 然后就可以添加内容了，在下面的一行下追加新增的用户： vim /etc/sudoers ## Allow root to run any commands anywher root ALL=(ALL) ALL youngyuan ALL=(ALL) ALL #这个是新增的用户 保存退出，这时候要记得将写权限收回： chmod -v u-w /etc/sudoers # mode of &quot;/etc/sudoers&quot; changed from 0640 (rw-r-----) to 0440 (r--r-----) 这时就可以用sudo -i登录root了。 ","link":"https://youngyuan1971.github.io/post/虚拟机安装Centos Linux及Docker(Mac)/"},{"title":"内网穿透工具NPS使用教程","content":"视频教程 请前往bilibili查看 https://www.bilibili.com/video/av74707117 https://www.bilibili.com/video/av76554314 与ngrok、frp等老牌内网穿透工具相比，nps可以算是一匹黑马。其优势主要有两点：一是强大的网页管理面板，nps可以在服务端通过网页管理所有用户行为以及映射记录；二是它集成了多种协议，包括tcp/udp隧道，socks5以及p2p，可以满足多种需求。 服务端安装 首先，我们需要一台拥有静态公网IP的服务器。国内推荐使用腾讯云或阿里云，国外推荐Linode以及hostus。不熟悉服务器租用流程的，可以直接在天猫搜索阿里云官方店铺向客服咨询开通流程。 服务器选购方面，建议购买Linux系统（推荐CentOS6/CentOS7），用作内网穿透的话对CPU性能、内存、以及硬盘容量都没有要求，选择最便宜的即可。网络带宽速度则取决于使用场景，可以大致参考以下表格 应用名称 协议 推荐服务器带宽 网络延迟（本地ping服务器 远程桌面 tcp/udp隧道 &gt;5mbps &lt;50ms 游戏开服 tcp/udp隧道 无要求 &lt;80ms 个人云端 p2p连接 无要求 无要求 个人云端 tcp/udp隧道 越快越好 无要求 游戏串流 socks5 &gt;10mbps &lt;30ms 网站调试 http/https 无要求 无要求 按自身需求购买服务器后，请从供应商处获取ssh登陆信息。Windows系统推荐下载PuTTY[官网下载|直接下载]或WinScp[官网下载|直接下载]进行ssh连接，Mac系统可直接在终端中输入指令连接 ssh -p &lt;服务器ssh端口，默认为22&gt; root@&lt;服务器IP地址&gt; ssh连接成功后，就可以开始配置服务端了。 首先请确保防火墙开放了所有端口，检查方式如下 iptables -L -n 如果得到以下结果则证明端口已全部开放 否则可以使用以下命令关闭防火墙 CentOS6: systemctl stop iptables systemctl disable iptables CentOS7: systemctl stop firewalld systemctl disable firewalld 如果你使用的是其他Linux发行版，或以上命令无效，请自行搜索Linux如何关闭防火墙。 另外，如果你使用了腾讯云或阿里云的服务器，则需要前往网页控制台配置防火墙，详细情况可咨询客服或搜索腾讯云/阿里云如何开放全端口。 确保全端口开通后，我们可以前往GitHub页面下载内网穿透软件nps了。请选择和自己系统对应的release版本，本篇教程使用Linux系统服务器，所以选择linux_amd64_server.tar.gz。右键复制下载链接，在ssh窗口中输入以下指令下载 wget --no-check-cetificate &lt;下载链接&gt; 下载完成后，可在ssh窗口输出&quot;ls&quot;查看当前目录下的文件，确认刚刚下载的压缩包是否存在 确认无误后，开始解压缩 tar -zxf ./&lt;压缩包名称&gt; 解压后，可以用&quot;ls&quot;看到目录下多出了一个nps文件夹，进入这个文件夹，并编辑配置文件 cd ./nps vi ./conf/nps.conf 按下&quot;i&quot;开始编辑，编辑完成后按&quot;Esc&quot;退出编辑模式，在输入&quot;:wq&quot;保存并退出。自带配置文件比较复杂仅供参考，以下为我自行精简过的配置文件，可用于替换原本的配置文件。标注的地方请按自身情况修改 appname = nps #Boot mode(dev|pro) runmode = dev ##bridge # 底层通信协议，默认tcp，可选用kcp bridge_type=tcp # 底层通信端口，默认8024，如已被占用请指定其他端口 bridge_port=8024 bridge_ip=0.0.0.0 # 当客户端以配置文件模式启动时会用到的验证密钥，可自行设置，本教程不会使用到 public_vkey=&lt;你的通信密钥&gt; #web web_host=&lt;服务器IP或域名&gt; web_username=&lt;设置用户名&gt; web_password=&lt;设置密码&gt; web_port = &lt;网页面板端口&gt; web_ip=0.0.0.0 编辑完成并保存退出后，请使用以下命令启动nps服务 ./nps start /* 后台启动服务 */ ./nps stop /* 结束后台进程 */ ./nps reload /* 重新加载配置 */ ./nps /* 前台启动服务 */ 启动后，可以访问网页管理面板（在浏览器中输入&quot;&lt;你服务器的IP或域名&gt;:&lt;网页面板端口&gt;&quot;），如果能打开网页并成功登陆，则说明服务端配置完成。 客户端配置 首先，在内网设备中下载对应的nps客户端，下载地址与服务端下载地址相同。本教程使用Windows10（64位）设备做演示，所以下载win_amd64_client.tar.gz（32位系统请下载i386的版本）。下载完成后，放在合适的目录并解压缩。 与传统内网穿透软件不同，nps最大的特点就是可以在网页面板完成所有对客户端的配置和管理，完全无需在客户端编辑配置文件（当然，如果你愿意，也可以在客户端完成所有配置而不去理会网页管理面板）。本篇教程将会演示如何使用网页进行配置。首先，登录管理面板&quot;&lt;服务端IP或域名&gt;:&lt;面板端口&gt;&quot;，在左侧导航栏找到&quot;客户端&quot;，并选择添加一个客户端 添加完成后，可以在列表中看到客户端信息，且客户端处于offline状态（因为我们还未在内网设备上输入指令连接服务端）。点击左侧按钮查看详细信息，我们可以看到系统生成（或手动指定）的通信密钥，以及客户端连接服务端的命令。 Windows下使用的命令与面板中显示的有所不同，请把&quot;./npc&quot;部分替换为&quot;npc&quot;， 前往存放nps客户端的目录并启动cmd（PowerShell是否可用还未测试)， 在打开的窗口中输入网页面板显示的连接指令 npc -server_addr=&lt;服务端IP或域名&gt;:8024 vkey=&lt;验证密钥&gt; type=tcp 如果没有报错，可以访问网页管理面板查看客户端是否变为online状态。如进入online状态，则可以添加内网穿透规则 tcp/udp隧道 使用场景 Windows远程桌面，ssh连接，vnc连接，游戏开服，内网架设dns服务器等 配置方法 以Windows远程桌面为例，其默认使用3389端口。假设局域网内有一台IP为192.168.1.100的Windows设备，那么，在同一局域网下，只要访问192.168.1.100:3389即可连接。但如果想要从外网连接，则必须添加一条tcp转发规则，把内网设备的3389端口，映射到服务端的某个端口，这里假设使用服务器的10000端口。假如服务器IP为12.34.56.78，那么，映射完成后，外网访问12.34.56.78:10000的请求会全部被转发到192.168.1.100:3389，也就是说，访问12.34.56.78:10000即可连接内网的windows设备。具体配置如下。 首先登录网页管理面板，查看并记住客户端id（例子中id是9）。选择左侧导航栏的tcp隧道，点击新增 完成后，尝试通过 服务器IP：外网端口 连接内网windows设备，如可以成功连接，则内网穿透成功。 添加udp隧道的方式与tcp类似，udp可用于映射内网dns服务器，根据自身需求配置即可。 p2p连接 使用场景 大文件传输，如在内网架设NAS，流量不经过服务器转发 要求 目标内网设备与访问端都需要运行npc，且二者NAT类型不能同时为对称型网络 配置方法 首先，我们需要编辑内网穿透服务器的配置文件，让服务器支持p2p穿透。先通过./nps stop停止服务，打开nps/conf/nps.conf，在末尾添加以下代码 #p2p p2p_ip=&lt;服务器公网IP，不要填域名，不要填127.0.0.1&gt; p2p_port=&lt;默认使用6000端口，可自行配置&gt; 请确保p2p_ip准确的填写了服务器的静态公网IP，否则会导致p2p穿透失败。编辑完成后保存并退出，使用./nps start重新启动服务。 之后，请前往网页管理面板添加一条p2p转发记录 需要注意的是，唯一验证密钥既被作为连接密码，也被作为目标端的身份标识。如果有多条p2p记录，请保证唯一验证密钥不要重复。 完成后，可以在记录下看到访问端需要输入的命令。 如果访问端为windows设备，请把&quot;./npc&quot;替换为&quot;npc&quot;。此项记录的意思是，把访问端的本地端口（默认为2000，可在命令后添加&quot;-local_port=xxx&quot;来指定)绑定到目标内网设备的目标端口3389。这样，只要在访问端输入127.0.0.1:2000就能连接目标设备的远程桌面了。如果访问端和目标端的NAT类型都符合要求，那么二者就可以直接通信，流量不需要再走服务器转发了。反之，如果NAT类型不符合要求，npc会报告p2p穿透失败，并继续使用服务器转发流量。 值得注意的是，手机、平板等无法运行npc的设备是无法直接使用p2p的。如果想使用p2p连接，则要保证同网段下至少有一台能运行npc的设备（假设该设备内网IP为192.168.1.10），然后再用手机平板访问192.168.1.10:2000（或自定义本地端口）来访问目标设备。 ","link":"https://youngyuan1971.github.io/post/内网穿透工具NPS使用教程/"},{"title":"安卓手机投屏-Scrcpy使用","content":"1. 概述 在Mac电脑上通过无线投屏操作安卓手机对于测试安卓设备非常方便，省去了电脑到安卓设备端来回奔波。下面介绍下Scrcpy一些常用方法。 2. Scrcpy常用操作 2.1 安装Scrcpy 安装Scrcpy需要依赖一些环境和软件，因此按照下面的顺序先配置环境，然后在安装Scrcpy。因版本不同可能会出现不兼容错误，可在网上找到答案，这里就不列出兼容的问题。 # 安装scrcpy brew install scrcpy # 安装adb环境 brew install android-platform-tools 2.2 Scrcpy使用 1. Scrcpy投屏 --adb连接安卓设备--- 1.android设备上打开usb调试模式 2.通过usb将电脑和android设备连接 3.查看当前可连接设备列表,下面的命令列出了当前可连接的安卓设备。 adb devices # Output: List of devices attached 2M22216008158776device 4.查看设备信息，例如ip地址。 # shell登录设备 adb shell # 查看设备ip地址 ifconfig 5.在电脑终端输入，定义端口 adb tcpip 5555 6.连接手机 adb connect 192.168.3.66:5555 # IP地址是android设备IP 7.连接成功后拔掉usb连接线就可以通过wifi操作android 8.断开连接 adb disconnect ---Scrcpy投屏--- 输入scrcpy即可启动投屏。 scrcpy 2. 录制屏幕 投屏状态下录屏 scrcpy --record file.mp4 scrcpy -r file.mkv 非投屏状态下录屏 scrcpy --no-display --record file.mp4 scrcpy -Nr file.mkv 2.3 scrcpy快捷键 描述 快捷键 切换全屏模式 cmd+f 显示左旋转 cmd+← 显示右旋转 cmd+→ 显示最佳窗口 cmd+g 显示窗口移除黑边 cmd+x 或在黑边上双击 返回到HOME cmd+h 或点击鼠标中键 返回 cmd+b 或鼠标右键 多任务 cmd+s 点击菜单 cmd+m 音量调大 cmd+↑ 音量调低 cmd+↓ 按手机电源 cmd+p 亮屏 鼠标右键 关闭设备屏幕（保持镜像） cmd+o 打开设备屏幕 cmd+Shift+o 旋转设备屏幕 cmd+r 下拉通知栏 cmd+n 收回通知栏 cmd+Shift+n 显示/不显示FPS计数 cmd+i 3. 常见错误 3.1 多个设备连接错误 当Mac通过adb连接了多个安卓设备后，启动Scrcpy就会报如下错误：ERROR: Multiple (2) ADB devices 表示无法选择投屏哪台设备，此时可断开adb连接的其他设备或者为Scrcpy选择一个投屏设备。 可通过命令 adb devices 查看已连接设备 List of devices attached SKPN45IF8DBMRG59 device 192.168.5.126:5555 device 选择其中一个设备，可以执行以下命令连接其中一个设备 scrcpy --serial SKPN45IF8DBMRG59 # 或者 scrcpy -s SKPN45IF8DBMRG59 ","link":"https://youngyuan1971.github.io/post/安卓手机投屏-Scrcpy使用/"},{"title":"Typora+PicGo搭建个人图床","content":"PicGo设置 设置GitHub为图床 图床设置选择HitHub： 仓库名：&lt;用户名&gt;/&lt;仓库名&gt; 分支名：main 存储路径：仓库存放图片的目录 Token：登录github，在Settings--Developer settings--Personal access tokens--Tokens(classic)中，生成Token，并记录。该信息仅显示一次，所以要牢记！ 自定义域名： # 官方：https://raw.githubusercontent.com/YoungYuan1971/TyporaPic/main # 加速：https://gcore.jsdelivr.net/gh/YoungYuan1971/TyporaPic@main 设置AList为图床 AList可以挂载阿里云盘、百度网盘、天翼云盘等网盘，支持WebDav协议，根据这个特性，可以将自己的网盘变成图床。 以阿里云盘为例： 在PicGo中安装插件：alist 图床设置选择alist： 版本：3 地址：alist的地址 上传路径：alist中的网盘路径 管理员Token：登录AList，在设置--其他中，复制令牌 访问路径：可选 我使用的是内网穿透方式，用公网IP上传图片，就可以在局域网外访问图片了 ","link":"https://youngyuan1971.github.io/post/Typora+PicGo搭建个人图床/"},{"title":"Typora入门","content":"简介 Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得写Markdown就象是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。 Typora删除了预览窗口，以及所有其他不必要的干扰。取而代之的是实时预览。 Markdown的语法因不同的解析器或编辑器而异，Typora使用的是GitHub Flavored Markdown。 Markdown介绍 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在2004年由约翰·格鲁伯（John Gruber）创建。 Markdown 编写的文档可以导出HTML、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 常用快捷键 本文在MacOS中撰写 Typora常用快捷键： Windows系统Ctrl键，Alt键，基本对应： Mac系统command键，option键 **但，**个别组合键的用法有所不同，可在菜单栏中查找 注：一些实体符号需要在实体符号之前加”\\”才能够显示 快捷键 效果 快捷键 效果 command+1 一级标题 command+2 二级标题 command+3 三级标题 command+4 四级标题 command+5 五级标题 command+6 六级标题 command+B 加粗 command+I 斜体 command+U 下划线 shift+contrl+` 删除线 command+D 选中当前单词 command+E 选中相同格式的文字 command+L 选中当前行 option+command+C 代码块 option+command+B 公式块 option+command+Q 引用 option+command+T 表格 option+command+I 图片 command+K 超链接 command+F 查找 块元素 换行符 在markdown中，段落由多个空格分隔。在Typora中，只需回车即可创建新段落。 标题级别 # 一级标题 快捷键为 command+1 ## 二级标题 快捷键为 command+2 ...... ###### 六级标题 快捷键为 command+6 展现 一级标题 快捷键为command+1 二级标题 快捷键为command+2 ...... 六级标题 快捷键为command+6 引用文字 &gt; 引用文字 展现 引用文字 无序列表 使用 * 和 - 都可以创建一个无序列表 - AAA - BBB - CCC 展现 AAA BBB CCC 有序列表 使用 1. 2. 3. 创建有序列表 1. AAA 2. BBB 3. CCC 展现 AAA BBB CCC 任务列表 - [ ] 不勾选 - [x] 勾选 展示 不勾选 勾选 代码块 在Typora中插入程序代码的方式有两种：使用反引号 `（~ 键）、使用缩进（Tab）。 插入行内代码，即插入一个单词或者一句代码的情况，使用 code 这样的形式插入。 插入多行代码输入3个反引号（`）+ 回车，并在后面选择一个语言名称即可实现语法高亮。 展示 def helloworld(): print(&quot;hello, world!&quot;) if __name__ == &quot;__main__&quot;: helloworld() 数学表达式 当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。根据需要加载 Mathjax 对数学公式进行渲染。 输入 $$，然后按下回车键，即可进行数学公式的编辑。 $$ \\mathbf{V}_1\\times\\mathbf{V}_2 = \\mathbf{X}_3 $$ 展现 V1×V2=X3\\mathbf{V}_1\\times\\mathbf{V}_2 = \\mathbf{X}_3 V1​×V2​=X3​ 表格 输入 | 表头1 | 表头2 |并回车。即可创建一个包含2列表。快捷键command+T弹出对话框。 不管是哪种方式，第一行为表头，第二行为分割表头和主体部分，第三行开始每一行为一个表格行 列与列之间用管道符号 | 隔开 还可设置对齐方式(表头与内容之间)，如果不使用对齐标记，内容默认左对齐，表头居中对齐 左对齐 ：| 右对齐 |： 中对齐 ：|： 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界 为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。 展现 表头1 表头2 表头3 表头1内容 表头2内容 表头3内容 脚注 这个例子的脚注为 [^1] 展示 这个例子的脚注为[1] 注意：该例子脚注标识是1，脚注标识可以为字母数字下划线，但是暂不支持中文。脚注内容可为任意字符，包括中文（脚注内容在本文最后）。 分割线 输入---或者***再按回车即可绘制一条水平线，如下： 展现 目录 输入[toc]然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。 展现 [toc] 跨度元素 跨度元素即图片，网址，视频等，在Typora中输入后，会立即载入并呈现。 链接 内部链接 这是一个带有标题属性的(鼠标悬停在链接有提示) [链接](http://example.com/ &quot;标题&quot;) 这是一个没有标题属性的 [链接](http://example.net/) 展示 链接 链接 引用链接 这个链接用 1 作为网址变量 [新浪][1] 这个链接用 google 作为网址变量 [Google][google] 然后在文档的结尾为变量赋值（网址） [1]: https://www.sina.com.cn/ &quot;新浪参考&quot; [2]: https://www.google.com/ &quot;google参考&quot; 展示 这个链接用 1 作为网址变量 新浪 这个链接用 google 作为网址变量 Google 标题链接 ### 要跳转的标题 我要跳转到[要跳转的内容](#要跳转的标题) 展示 要跳转的标题 在本文最后跳转 网址 Typora允许用&lt;括号括起来&gt;, 把URL作为链接插入。 Typora还会自动链接标准网址。 &lt;https://www.baidu.com&gt; 展示 https://www.baidu.com 图片 ![显示的文字](C:\\Users\\Hider\\Desktop\\echart.png &quot;图片标题&quot;) ![显示的文字](C:\\Users\\Hider\\Desktop\\echart.png) 除了以上2种方式之外，还可以直接将图片拖拽进来，自动生成链接。 强调语法 斜体 使用*单个星号*或者_单下划线_可以字体倾斜。快捷键command+I *斜体* 或 _斜体_ 展示 斜体 加粗 使用**两个星号**或者__两个下划线__可以字体加粗。快捷键command+B **加粗** 或 __加粗__ 展示 加粗 加粗斜体 使用***加粗斜体***可以加粗斜体。 ***加粗斜体*** 展示 加粗斜体 代码标记 标记代码使用反引号，即在英文输入法下，ESC键下面和1键左边的符号。 使用`printf()`功能 展示 使用该printf()功能 删除线 使用~~删除线~~ 快捷键 Alt+Shift+5 ~~删除线~~ 展示 删除线 下划线 通过&lt;u&gt;下划线的内容&lt;/u&gt; 或者 快捷键command+U可实现下划线 &lt;u&gt;下划线的内容&lt;/u&gt; 展示 下划线的内容 高亮 ==高亮==(需在设置中打开该功能) ==我是最重要的== 展示 我是最重要的 下标 可以使用~文本~或者&lt;sub&gt;文本&lt;/sub&gt;实现下标。 (需在设置中打开该功能) H~2~O 或者 H&lt;sub&gt;2&lt;/sub&gt;O 展示 H2O 或者 H2O 上标 可以使用^文本^或者&lt;sup&gt;文本&lt;/sup&gt;实现上标。 (需在设置中打开该功能) x^2^ 或者 x&lt;sup&gt;2&lt;sup&gt; 展示 x2 或者 x2 文本居中 使用&lt;center&gt;这是要居中的内容&lt;/center&gt;可以使文本居中 &lt;center&gt;这是要居中的内容&lt;/center&gt; 展示 这是要居中的内容 标题居中 以三级标题为例: &lt;h3 style=&quot;text-align:center&quot;&gt;这是居中的三级标题&lt;/h3&gt; 展示 这是居中的三级标题 换行符 使用空格+空格+Enter可以实现换行 或者可以使用&lt;br&gt;实现换行。 &lt;br&gt; 转义语法 Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 展示 文本加粗 ** 正常显示星号 ** Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号 HTML 支持HTML 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如： 使用&lt;kbd&gt;command&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;重启电脑 &lt;kbd&gt; &lt;/kbd&gt; -- 白色框框 展示 使用command+Alt+Del重启电脑 -- 白色框框 总结 建议打开大纲视图command+Shift+1 插入表格需要顶格写，否则无法显示 我要跳转到要跳转的内容 本文引用链接： 本文脚注内容： 这里是脚注的内容 ↩︎ ","link":"https://youngyuan1971.github.io/post/Typora入门/"},{"title":"Markdown中公式编辑教程","content":"希腊字母 名称 大写 code 小写 code alpha A A α \\alpha beta B B β \\beta gamma Γ \\Gamma γ \\gamma delta Δ \\Delta δ \\delta epsilon E E ϵ \\epsilon zeta Z Z ζ \\zeta eta H H η \\eta theta Θ \\Theta θ \\theta iota I I ι \\iota kappa K K κ \\kappa lambda Λ \\Lambda λ \\lambda mu M M μ \\mu nu N N ν \\nu xi Ξ \\Xi ξ \\xi omicron O O ο \\omicron pi Π \\Pi π \\pi rho P P ρ \\rho sigma Σ \\Sigma σ \\sigma tau T T τ \\tau upsilon Υ υ \\upsilon phi Φ \\Phi ϕ \\phi chi X X χ \\chi psi Ψ \\Psi ψ \\psi omega Ω \\Omega ω \\omega 上标与下标 上标和下标分别使用^ 与_ ，例如$x_i^2$表示的是：xi2x_i^2xi2​ 默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用{..} 包裹起来的内容。如果使用$10^10$ 表示的是101010^101010，而$10^{10}$ 才是101010^{10}1010 同时，大括号还能消除二义性，如x^5^6 将得到一个错误，必须使用大括号来界定^的结合性，如${x^5}^6$ x56{x^5}^6x56：或者$x^{5^6}$ ：x56x^{5^6}x56 括号 小括号与方括号 使用原始的( ) ，[ ] 即可，如$(2+3)[4+4]$ ： (2+3)[4+4](2+3)[4+4](2+3)[4+4] 使用\\left(或\\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如$\\left(\\frac{x}{y}\\right)$ ：(xy)\\left(\\frac{x}{y}\\right)(yx​) 大括号 由于大括号{} 被用于分组，因此需要使用\\{和\\}表示大括号，也可以使用\\lbrace 和\\rbrace来表示。如$\\{a*b\\}:a*b$ 或$\\lbrace a*b\\rbrace :a*b$ 表示{a∗b}:a∗b\\{a*b\\}:a*b{a∗b}:a∗b 尖括号 区分于小于号和大于号，使用\\langle 和\\rangle 表示左尖括号和右尖括号。如$\\langle x \\rangle$ 表示：⟨x⟩\\langle x \\rangle⟨x⟩ 上取整 使用\\lceil 和 \\rceil 表示。 如，$\\lceil x \\rceil$：⌈x⌉\\lceil x \\rceil⌈x⌉ 下取整 使用\\lfloor 和 \\rfloor 表示。如，$\\lfloor x \\rfloor$：⌊x⌋\\lfloor x \\rfloor⌊x⌋ 求和与积分 求和 \\sum 用来表示求和符号，其下标表示求和下限，上标表示上限。如: $\\sum_{r=1}^n$表示：∑r=1n\\sum_{r=1}^n∑r=1n​ $$\\sum_{r=1}^n$$表示：$$\\sum_{r=1}^n$$ 积分 \\int 用来表示积分符号，同样地，其上下标表示积分的上下限。如，$\\int_{r=1}^\\infty$：∫r=1∞\\int_{r=1}^\\infty∫r=1∞​ 多重积分同样使用 int ，通过 i 的数量表示积分导数： $\\iint$ ：∬\\iint∬ $\\iiint$ ：∭\\iiint∭ $\\iiiint$ ：\\iiiint 连乘 $\\prod {a+b}$，输出：∏a+b\\prod {a+b}∏a+b $\\prod_{i=1}^{K}$，输出：∏i=1K\\prod_{i=1}^{K}∏i=1K​ $$\\prod_{i=1}^{K}$$，输出：$$\\prod_{i=1}^{K}$$ 其他 与此类似的符号还有， $\\prod$ ：∏\\prod∏ $\\bigcup$ ：⋃\\bigcup⋃ $\\bigcap$ ：⋂\\bigcap⋂ $arg\\,\\max_{c_k}$：arg max⁡ckarg\\,\\max_{c_k}argmaxck​​ $arg\\,\\min_{c_k}$：arg min⁡ckarg\\,\\min_{c_k}argminck​​ $\\mathop {argmin}_{c_k}$：argminck\\mathop {argmin}_{c_k}argminck​​ $\\mathop {argmax}_{c_k}$：argmaxck\\mathop {argmax}_{c_k}argmaxck​​ $\\max_{c_k}$：max⁡ck\\max_{c_k}maxck​​ $\\min_{c_k}$：min⁡ck\\min_{c_k}minck​​ 分式与根式 分式 第一种，使用$\\frac ab$，\\frac作用于其后的两个组a ，b ，结果为ab\\frac abba​ 如果你的分子或分母不是单个字符，请使用{..}来分组，比如$\\frac {a+c+1}{b+c+2}$表示a+c+1b+c+2\\frac {a+c+1}{b+c+2}b+c+2a+c+1​ 第二种，使用\\over来分隔一个组的前后两部分，如${a+1\\over b+1}$：a+1b+1{a+1\\over b+1}b+1a+1​ 连分数 书写连分数表达式时，请使用\\cfrac代替\\frac或者\\over两者效果对比如下： \\frac 表示如下： $$x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}$$ 显示如下： x=a0+12a1+22a2+32a3+42a4+...x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}} x=a0​+a1​+a2​+a3​+a4​+...42​32​22​12​ \\cfrac 表示如下： $$x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}$$ 显示如下： x=a0+12a1+22a2+32a3+42a4+...x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}} x=a0​+a1​+a2​+a3​+a4​+...42​32​22​12​ 根式 根式使用\\sqrt 来表示。 如开4次方：$\\sqrt[4]{\\frac xy}$ ：xy4\\sqrt[4]{\\frac xy}4yx​​ 开平方：$\\sqrt {a+b}$：a+b\\sqrt {a+b}a+b​ 多行表达式 分类表达式 定义函数的时候经常需要分情况给出表达式，使用\\begin{cases}…\\end{cases} 。其中： 使用\\\\ 来分类 使用&amp; 指示需要对齐的位置 使用\\ +空格表示空格 $$ f(n) \\begin{cases} \\cfrac n2, &amp;if\\ n\\ is\\ even\\\\ 3n + 1, &amp;if\\ n\\ is\\ odd \\end{cases} $$ 表示: f(n){n2,if n is even3n+1,if n is oddf(n) \\begin{cases} \\cfrac n2, &amp;if\\ n\\ is\\ even\\\\ 3n + 1, &amp;if\\ n\\ is\\ odd \\end{cases} f(n)⎩⎨⎧​2n​,3n+1,​if n is evenif n is odd​ $$ L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\\\ 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases} $$ 表示: L(Y,f(X))={0,Y = f(X)1,Y ≠ f(X)L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\\\ 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases} L(Y,f(X))={0,1,​Y = f(X)Y ​= f(X)​ 如果想分类之间的垂直间隔变大，可以使用\\\\[2ex] 代替\\\\ 来分隔不同的情况。(3ex,4ex 也可以用，1ex 相当于原始距离)。如下所示： $$ L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\\\[5ex] 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases} $$ 表示： L(Y,f(X))={0,Y = f(X)1,Y ≠ f(X)L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\\\[5ex] 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases} L(Y,f(X))=⎩⎪⎪⎨⎪⎪⎧​0,1,​Y = f(X)Y ​= f(X)​ 多行表达式 有时候需要将一行公式分多行进行显示。 $$ \\begin{equation}\\begin{split} a&amp;=b+c-d \\\\ &amp;\\quad +e-f\\\\ &amp;=g+h\\\\ &amp; =i \\end{split}\\end{equation} $$ 表示： \\begin{equation}\\begin{split} a&amp;=b+c-d \\\\ &amp;\\quad +e-f\\\\ &amp;=g+h\\\\ &amp; =i \\end{split}\\end{equation} 其中begin{equation} 表示开始方程，end{equation} 表示方程结束；begin{split} 表示开始多行公式，end{split} 表示结束；公式中用\\\\ 表示回车到下一行，&amp; 表示对齐的位置。 方程组 使用\\begin{array}...\\end{array} 与\\left \\{ 与\\right. 配合表示方程组: $$ \\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{array} \\right. $$ 表示： {a1x+b1y+c1z=d1a2x+b2y+c2z=d2a3x+b3y+c3z=d3\\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{array} \\right. ⎩⎨⎧​a1​x+b1​y+c1​z=d1​a2​x+b2​y+c2​z=d2​a3​x+b3​y+c3​z=d3​​ 注意：通常MathJax通过内部策略自己管理公式内部的空间，因此a…b 与a…….b （.表示空格）都会显示为ab 。可以通过在ab 间加入\\ ,增加些许间隙，\\; 增加较宽的间隙，\\quad 与\\qquad 会增加更大的间隙。 特殊函数与符号 三角函数 sinx :sinxsinxsinx arctanx :arctanxarctanxarctanx 比较运算符 小于(\\lt ): &lt;\\lt&lt; 大于(\\gt ): &gt;\\gt&gt; 小于等于(\\le ): ≤\\le≤ 大于等于(\\ge ): ≥\\ge≥ 不等于(\\ne ) : ≠\\ne​= 可以在这些运算符前面加上\\not ，如$\\not\\lt$ : &lt;\\not\\lt​&lt; 集合关系与运算 并集(\\cup ): ∪\\cup∪ 交集(\\cap ): ∩\\cap∩ 差集(\\setminus ): ∖\\setminus∖ 子集(\\subset ): ⊂\\subset⊂ 子集(\\subseteq ): ⊆\\subseteq⊆ 非子集(\\subsetneq ): ⊊\\subsetneq⊊ 父集(\\supset ): ⊃\\supset⊃ 属于(\\in ): ∈\\in∈ 不属于(\\notin ): ∉\\notin∈/​ 空集(\\emptyset ): ∅\\emptyset∅ 空(\\varnothing ): ∅\\varnothing∅ 排列 \\binom{n+1}{2k} : (n+12k)\\binom{n+1}{2k}(2kn+1​) {n+1 \\choose 2k} : (n+12k){n+1 \\choose 2k}(2kn+1​) 箭头 \\to: →\\to→ \\rightarrow: →\\rightarrow→ \\leftarrow: ←\\leftarrow← \\Rightarrow: ⇒\\Rightarrow⇒ \\Leftarrow: ⇐\\Leftarrow⇐ \\mapsto: ↦\\mapsto↦ 逻辑运算符 \\land: ∧\\land∧ \\lor: ∨\\lor∨ \\lnot: ¬\\lnot¬ \\forall: ∀\\forall∀ \\exists: ∃\\exists∃ \\top: ⊤\\top⊤ \\bot: ⊥\\bot⊥ \\vdash: ⊢\\vdash⊢ \\vDash: ⊨\\vDash⊨ 操作符 \\star: ⋆\\star⋆ \\ast: ∗\\ast∗ \\oplus: ⊕\\oplus⊕ \\circ: ∘\\circ∘ \\bullet: ∙\\bullet∙ 等于 \\approx: ≈\\approx≈ \\sim: ∼\\sim∼ \\equiv: ≡\\equiv≡ \\prec: ≺\\prec≺ 范围 \\infty: ∞\\infty∞ \\aleph_o: ℵo\\aleph_oℵo​ \\nabla: ∇\\nabla∇ \\Im: ℑ\\Imℑ \\Re: ℜ\\Reℜ 模运算 \\pmod: 如a \\equiv b \\pmod n : a≡b(modn)a \\equiv b \\pmod na≡b(modn) 点 \\ldots: …\\ldots… \\cdots: ⋯\\cdots⋯ \\cdot: ⋅\\cdot⋅ 其区别是点的位置不同，\\ldots 位置稍低，\\cdots 位置居中。 $$ \\begin{equation} a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n \\end{equation} $$ 表示： \\begin{equation} a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n \\end{equation} 顶部符号 对于单字符，\\hat x ：x^\\hat xx^ 多字符可以使用\\widehat {xy} ：xy^\\widehat {xy}xy​ 类似的还有:\\overline x: x‾\\overline xx 向量(\\overrightarrow {xy}): xy→\\overrightarrow {xy}xy​ \\dot x: x˙\\dot xx˙ \\ddot x: x¨\\ddot xx¨ \\dot {\\dot x}: x˙˙\\dot {\\dot x}x˙˙ 表格 使用\\begin{array}{列样式}…\\end{array} 这样的形式来创建表格，列样式可以是clr 表示居中，左，右对齐，还可以使用| 表示一条竖线。表格中各行使用\\\\ 分隔，各列使用&amp; 分隔。使用\\hline 在本行前加入一条直线。 例如: $$ \\begin{array}{c|lcr} n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\\\ 2 &amp; -1 &amp; 189 &amp; -8 \\\\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\ \\end{array} $$ 得到： nLeftCenterRight10.2411252−1189−83−2020001+10i\\begin{array}{c|lcr} n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\\\ 2 &amp; -1 &amp; 189 &amp; -8 \\\\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\ \\end{array} n123​Left0.24−1−20​Center11892000​Right125−81+10i​​ 矩阵 基本内容 使用\\begin{matrix}…\\end{matrix} 这样的形式来表示矩阵，在\\begin 与\\end 之间加入矩阵中的元素即可。矩阵的行之间使用\\\\ 分隔，列之间使用&amp; 分隔，例如: $$ \\begin{matrix} 1 &amp; x &amp; x^2 \\\\ 1 &amp; y &amp; y^2 \\\\ 1 &amp; z &amp; z^2 \\\\ \\end{matrix} $$ 得到： 1xx21yy21zz2\\begin{matrix} 1 &amp; x &amp; x^2 \\\\ 1 &amp; y &amp; y^2 \\\\ 1 &amp; z &amp; z^2 \\\\ \\end{matrix} 111​xyz​x2y2z2​ 括号 如果要对矩阵加括号，可以像上文中提到的一样，使用\\left 与\\right 配合表示括号符号。也可以使用特殊的matrix 。即替换\\begin{matrix}…\\end{matrix} 中matrix 为pmatrix ，bmatrix ，Bmatrix ，vmatrix , Vmatrix 。 pmatrix$\\begin{pmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{pmatrix}$ : (1234)\\begin{pmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{pmatrix}(13​24​) bmatrix$\\begin{bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{bmatrix}$ : [1234]\\begin{bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{bmatrix}[13​24​] Bmatrix$\\begin{Bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Bmatrix}$ : {1234}\\begin{Bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Bmatrix}{13​24​} vmatrix$\\begin{vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{vmatrix}$ : ∣1234∣\\begin{vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{vmatrix}∣∣∣∣​13​24​∣∣∣∣​ Vmatrix$\\begin{Vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Vmatrix}$ : ∥1234∥\\begin{Vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Vmatrix}∥∥∥∥​13​24​∥∥∥∥​ 元素省略 可以使用\\cdots ：⋯，\\ddots：⋱ ，\\vdots：⋮ 来省略矩阵中的元素，如： $$ \\begin{pmatrix} 1&amp;a_1&amp;a_1^2&amp;\\cdots&amp;a_1^n\\\\ 1&amp;a_2&amp;a_2^2&amp;\\cdots&amp;a_2^n\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ 1&amp;a_m&amp;a_m^2&amp;\\cdots&amp;a_m^n\\\\ \\end{pmatrix} $$ 表示： (1a1a12⋯a1n1a2a22⋯a2n⋮⋮⋮⋱⋮1amam2⋯amn)\\begin{pmatrix} 1&amp;a_1&amp;a_1^2&amp;\\cdots&amp;a_1^n\\\\ 1&amp;a_2&amp;a_2^2&amp;\\cdots&amp;a_2^n\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ 1&amp;a_m&amp;a_m^2&amp;\\cdots&amp;a_m^n\\\\ \\end{pmatrix} ⎝⎜⎜⎜⎛​11⋮1​a1​a2​⋮am​​a12​a22​⋮am2​​⋯⋯⋱⋯​a1n​a2n​⋮amn​​⎠⎟⎟⎟⎞​ 增广矩阵 增广矩阵需要使用前面的表格中使用到的\\begin{array} ... \\end{array} 来实现。 $$ \\left[ \\begin{array} {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线 1 &amp; 2 &amp; 3 \\\\ \\hline %插入横线，如果去掉\\hline就是增广矩阵 4 &amp; 5 &amp; 6 \\end{array} \\right] $$ 显示为： [123456]\\left[ \\begin{array} {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线 1 &amp; 2 &amp; 3 \\\\ \\hline %插入横线，如果去掉\\hline就是增广矩阵 4 &amp; 5 &amp; 6 \\end{array} \\right] [14​25​36​​] 字体 黑板粗体字 此字体经常用来表示代表实数、整数、有理数、复数的大写字母。 $\\mathbb ABCDEF$：ABCDEF\\mathbb ABCDEFABCDEF $\\Bbb ABCDEF$：ABCDEF\\Bbb ABCDEFABCDEF 黑体字 $\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$ : ABCDEFGHIJKLMNOPQRSTUVWXYZ\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ $\\mathbf abcdefghijklmnopqrstuvwxyz$ : abcdefghijklmnopqrstuvwxyz\\mathbf abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz 打印机字体 $\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$ : ABCDEFGHIJKLMNOPQRSTUVWXYZ\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ ","link":"https://youngyuan1971.github.io/post/markdown中公式编辑教程/"}]}